---
title: "执行器与线程池"
date: 2020-11-03
lastmod: 2020-11-03
draft: false
tags: [Java进阶]
categories: [Java]
author: "wangy325"

hasJCKLanguage: true

weight: 10
mathjax: true
autoCollapseToc: false
---

本系列的文章到目前为止，虽然没有特别说明，但是使用执行器(Executor(s))的次数已经难以计数了，`Executors`提供了一些非常方便的静态方法，可以根据需要创建不同的`ExecutorService`，然后调用其`execute(Runnable)`或`submit(Callable<T>)`方法。在多线程的条件下，执行器还有一个非常明显的优势，它使用线程池管理线程，避免了系统创建和销毁线程的开销。在一般的Java并发过程中，也建议使用执行器完成任务而非显式地创建线程

本文将从执行器开始，阐述Java中的线程池

<!--more-->

# 1 Executors

`java.util.concurrent.Executors`类提供了许多静态方法来获取不同类型的 **线程池**，下表列出其常用方法[^1]：

|方法|概要|
| :-- | :--|
|newFixedThreadPool|创建固定大小的线程池，线程会一直保留|
|newCachedThreadPool|创建线程池，该线程池在必要时创建新线程，旧线程也会被重用，线程空闲60s被销毁|
|newSingleThreadExecutor|相当于newFixedThreadPool(1)，其能保证任务顺序执行|
|newScheduledThreadPool|用于预定执行一次或周期执行的线程池|
|newSingleThreadScheduledExecutor|用于预定执行一次或周期执行的单线程池|

<p style="text-align:center; font-size:.9rem; font-style:italic">Executors用于构造线程池的部分方法</p>

上表中的前3个方法返回`ThreadPoolExecutor`实例，后面2个方法返回`ScheduledExecutorService`接口的实例，不管是ThreadPoolExecutor或是ScheduledExecutorService，都是`ExecutorService`的实现，`ExecutorService`接口是设计用来处理任务的接口，其顶层接口是`java.util.concurrent.Executor`，该接口简单地定义了一个执行任务的方法：

```Java
public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be
     * accepted for execution
     * @throws NullPointerException if command is null
     */
    void execute(Runnable command);
}
```

因此对执行器的讨论最终要回到对`Executor`及其实现上来

# 2 Executor 框架

前文就已经提过，`Executors`构建的线程池包括不同实现，可以应对不同的场景，那么Java中包含哪些实现呢？

<center>
![xx](/img/executor.png)
</center>
<p style="text-align:center; font-size:.9rem; font-style:italic">Executor框架组成</p>

<!--
下图展示了Executor框架的执行逻辑[^2]

<center>
![xx](/img/executor_execution.png)
</center>
<p style="text-align:center; font-size:.9rem; font-style:italic">Executor框架执行图</p>
-->

从上面的框架组成图中，可以清晰的看到使用`Executors`能够构建所有线程池实例，

`ExecutorService`接口定义了一系列和线程池以及任务相关的基本方法，用于检查关闭/关闭线程池，提交任务，执行任务等

`AbstractExecutorService`直接实现了`ExecutorService`的invokeAny/invokeAll方法。此外，从该类的源码可以清晰地看到，所有的任务都是通过转化为`RunnableFuture`(FutureTask)而后通过`execute(Runnable)`方法执行的

```java
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    return new FutureTask<T>(callable);
}

public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<T> ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}

protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
    return new FutureTask<T>(runnable, value);
}

public Future<?> submit(Runnable task) {
   if (task == null) throw new NullPointerException();
   RunnableFuture<Void> ftask = newTaskFor(task, null);
   execute(ftask);
   return ftask;
}

public <T> Future<T> submit(Runnable task, T result) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<T> ftask = newTaskFor(task, result);
    execute(ftask);
    return ftask;
}
```

`ScheduledExecutorService`接口继承自`ExecutorService`，定义了用于计划执行或周期执行的线程池方法

`ThreadPoolExecutor`继承自`AbstractExecutorService`，是线程池重要的实现之一

`ScheduledThreadPoolExecutor`继承自`ScheduledExecutorService`，是线程池重要的实现之二

`ForkJoinPool`继承自`AbstractExecutorService`，是线程池的重要实现之三，关于它的内容将单独展开

`DelegatedExecutorService`继承自`AbstractExecutorService`，它是`Executors`的内部类，是一个仅仅实现了`ExecutorService`方法的包装类，其有两个子类分别是`DelegatedScheduledExecutorServide`和`FinalizableDelegatedExecutorService`

`CompletionService`接口有一个子类`ExecutorCompletionService`，该类由执行器实例化，用来管理执行器执行的任务的结果



## 2.1 ExecutorService

<!--
<center>
![xx](/img/executor_service_method_table.png)
</center>
<p style="text-align:center; font-size:.9rem; font-style:italic">ExecutorService方法表</p>
-->
ExecutorService是次顶层接口，定义了线程池操作任务的基本方法

```java
// 继承自Executor的方法
void execute(Runnable command);

void shutdown();
    /*有序地关闭线程池，已经提交（在运行或已经在队列中）的任务不会受到影响，将继续执行，
    但线程池不接受新任务的提交

    此法不会在当前线程上等待线程池后台任务的执行结果（或者任务执行后的作用），换言之，
    如果想要获取任务执行之后的结果，调用此法无法达到目的*/

List<Runnable> shutdownNow();
    /*尝试去停止(stop)所有活动的任务，已提交且队列中的中的任务将取消执行，并返回取消的任务队列。
    向正在执行的任务发送中断命令，那些无法响应中断命令的任务将无法中止

    和shutdown()方法一样，此法不会等待正在执行的任务终止*/

boolean isShutdown();
    // 如果线程池已经关闭，返回true

boolean isTerminated();
    /*如果所有的任务都完成（中止运行或正常运行完成），则返回true

    注意，若没有先调用shutdown()或shutdownNow()，此方法不可能返回true*/

boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    /*线程池shutdown请求之后，阻塞当前线程，等待任务执行。当超时，任务执行完毕，或当前线程被中断
    任一情况发生时，终止阻塞*/

<T> Future<T> submit(Callable<T> task);
    // 提交一个有返回结果的Callable任务

<T> Future<T> submit(Runnable task, T result);
    // 提交一个Runnable并指定其返回result

Future<?> submit(Runnable task);
    /*提交一个Runnable，返回的Future<?>的get方法将返回null，其主要目的是利用Future的其他
    方法控制任务的执行*/

<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;
    /*执行集合中包含的任务，并返回一个Future<T>集合，Future<T>集合包含各个任务的执行状态及结果

    Future<T>集合中的的顺序和任务集合中的迭代顺序是一致的

    这个方法会等待所有的任务执行完成（正常执行或抛出异常），如果任务集合在执行过程中被修改，那么
    任务的结果将会变为undefined*/

<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
    /* 执行集合中包含的任务，在所有任务执行完成或超时之前返回一个Future<T>集合。在返回之前，
    未能执行的任务将被取消

    其他的特征和重载方法一致*/

<T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;
    /* 执行给定的任务集合中的任务，返回任何一个成功执行的任务的结果，其他未完成的任务被取消

    如果任务集合在执行过程中被修改，那么任务的结果将会变为undefined*/

<T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
    /* 执行给定的任务集合中的任务，在超时之前返回任何一个成功执行的任务的结果，
    其他未完成的任务被取消

    如果任务集合在执行过程中被修改，那么任务的结果将会变为undefined*/
```

如上所示，ExecutorService定义了线程池的基本方法，其中`invokeAny`和`invokeAll`方法在`AbstractExecutorService`中实现


## 2.2 ThreadPoolExecutor

该类是执行器(线程池)的核心类，一般来讲，Java的线程池，指的就是ThreadPoolExecutor实例

### 2.2.1 构造器

ThreadPoolExecutor提供了4个构造器用来构造线程池实例

```java

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
        threadFactory, defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), handler);
}

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null : AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

从构造器来看呢，要构建一个线程池实例，至少需要提供5个参数，另外2个参数不提供则可以使用默认配置[^3]，这些参数分别是：

|参数|描述|
| :-- | :-- |
|corePoolSize| 核心线程池大小|
|maximumPoolSize| 最大线程池大小|
|keepAliveTime |非核心线程执行完任务后最长的空间等待时间，超时则销毁线程|
|unit|keepAliveTime的单位|
|workQueue|用于保存待执行任务的队列|
|threadFactory|用于创建线程的线程工厂|
|handler|线程池满载（队列无空间，且不能新建线程）后，处理新提交任务的拒绝策略|

这些构造器参数就是线程池的核心概念，理解这几个参数在线程池运行过程中的意义便理解了线程池的大半


### 2.2.2 核心概念

#### **核心线程池与最大线程池**

线程池的`getPoolSize()`方法返回的线程数不应该超过线程池的核心线程池大小（corePoolSize）**或** 最大线程池大小（maximumPoolSize）。线程池中的工作线程数不可能超过最大线程池大小。若想获得当前的正在执行任务的线程数，需使用`getActiveCount()`方法

当一个任务被提交至线程池后[^4]，若：

- 当前工作线程数 < corePoolSize，新建一个线程来完成任务——尽管可能有空闲核心线程
    (当工作线程数 < corePoolSize时，任务队列一定是空的)
- corePoolSize < 当前工作线程数 < maximumPoolSize，并且任务队列已满，那么新建一个**非核心线**程来完成任务

当设置corePoolSize=maximumPoolSize时，你将获得一个固定容量的线程池；当将maxPoolSize设置为Integer.MAX_VALUE时，线程数没有限制，这有可能造成**内存泄漏**

尽管在构建线程池实例时要指定corePoolSize和maximumPoolSize，在获得实例之后还可以通过`setCorePoolSize(int)`和`setMaximumPoolSize(int)`来对其进行修改[^5]

默认情况下，当线程池初始化成功之后，池中是**没有任何线程的**。不过，可以调用`prestartCoreThread()`和`prestartAllCoreThreads()`来向线程池中添加一个或所有核心线程。如果你使用一个非空的任务队列初始化线程池，这样做是有用的

```Java
@SneakyThrows
void initPoolWithNonEmptyQueue() {
    BlockingQueue<Runnable> queue = new ArrayBlockingQueue<Runnable>(2) {{
        add(() -> {
            System.out.println("1st task done");
        });
        add(()->{
            System.out.println("2nd task done");
        });
    }};

    ThreadPoolExecutor.AbortPolicy abortPolicy = new ThreadPoolExecutor.AbortPolicy();
    ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(1, 1,
        0, TimeUnit.MILLISECONDS, queue, abortPolicy);

    poolExecutor.prestartCoreThread();
    poolExecutor.shutdown();

}
/* output
1st task done
2nd task done
*///:~
```
使用`prestartCoreThread()`还有一个好处，它可以保证队列中的任务顺序执行

#### **创建新线程**

线程池中的线程使用线程工厂`ThreadFactory`创建，如果没有指定，将使用`Executors.defaultThreadFactory`。如果线程工厂在创建线程时失败而返回null，那么线程池将无法执行任何任务

#### **存活时间**

keepAliveTime针对的是非核心线程，非核心线程处理完任务后，若在keepAliveTime内没有新任务添加到队列并被其获取并运行，其将被销毁。这是一种资源保护策略，如果线程池的任务突然增多，可能又会创建非核心线程来完成任务。当corePoolSize = maximumPoolSize时，线程池无法创建非核心线程，此时keepAliveTime参数可能没有意义，一般将其设置为0

但凡事并非绝对，`ThreadPoolExecutor`维护一个布尔型变量`allowCoreThreadTimeOut`，其默认值是false，用来控制核心线程池的“生命”：

```java
/**
 * If false (default), core threads stay alive even when idle.
 * If true, core threads use keepAliveTime to time out waiting
 * for work.
 */
private volatile boolean allowCoreThreadTimeOut;
```
这个变量的值由`allowCoreThreadTimeOut(boolean value)`方法修改

```java
public void allowCoreThreadTimeOut(boolean value) {
    if (value && keepAliveTime <= 0)
        throw new IllegalArgumentException("Core threads must have nonzero keep alive times");
    if (value != allowCoreThreadTimeOut) {
        allowCoreThreadTimeOut = value;
        if (value)
            interruptIdleWorkers();
    }
}
```
可以看到，如果将变量`allowCoreThreadTimeOut`的值设置为true，那么空闲的核心线程池也将会在keepAliveTime超时之后被销毁(如果没有任务让其执行)

#### **任务队列**

任务队列是一个阻塞队列，一个线程池中只有一个任务队列。任务队列用于缓存当前尚没有线程可执行之的任务，其和线程池之间存在如下的交互关系：

- 如果当前工作线程 < corePoolSize，线程池将创建新线程执行任务而非将任务放入队列
- 如果当前工作线程 > corePoolSize，线程池倾向于将任务放入队列而非创建新线程执行之
- 如果任务无法放入队列（满），并且当前工作线程 < maximumPoolSize，将创建新线程执行之，否则任务将**被拒绝**

任务队列有3种常见实现：

1. 直接运行(direct handoffs)，这种情形的任务队列一般由[SynchronousQueue](../生产者-消费者与阻塞队列/#2-3-synchronousqueue)实现，这种队列的实现对线程池的要求严苛，如果没有可用的线程即刻执行任务，那么将任务放入队列将失败。在此情形下，一般将maximumPoolSize设置为Integer.MAX_
VALUE以防止线程池拒绝任务。这种实现可能会导致内存泄漏

2. 无界任务队列， 一般由[LinkedBlockingQueue](../生产者-消费者与阻塞队列/#2-2-linkedblockingqueue)实现，这种情形下，当当前工作线程达到corePoolSize之后，所有新提交的任务都会放入队列中，由于队列无界，就**不会**再创建新线程了，也不会拒绝任务。因此maximumPoolSize这一设置将无意义。如果任务源源不断地提交，有可能任务积压导致内存泄漏

3. 有界队列，一般由[ArrayBlockingQueue](../生产者-消费者与阻塞队列/#2-1-arrayblockingqueue)实现，使用有界队列可以避免资源耗尽，但是也增加了配置的难度，是应该配置更多的线程数更小的队列还是应该配置更大的队列更少的线程数，往往需要根据具体的任务来考量

#### **拒绝策略**

前面提到，如果线程池满载，新提交的任务就会被线程池拒绝执行；同样的，如果线程池关闭了，提交任务也会被拒绝。线程池通过调用`RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)`来拒绝任务，`ThreadPoolExecutor`内建了4种不同的拒绝策略

1） `ThreadPoolExecutor.AbortPolicy`，也是默认的拒绝策略，该策略直接抛出`RejectedExecutionException`的运行时异常

```Java
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    throw new RejectedExecutionException("Task " + r.toString() +
                                         " rejected from " +
                                         e.toString());
}
```

2） `ThreadPoolExecutor.CallerRunsPolicy`，如果线程池未关闭，该策略直接在执行`execute()`方法的线程上运行任务，否则该任务被丢弃

```java
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
        r.run();
    }
}
```

3）`ThreadPoolExecutor.DiscardPolicy`，该策略直接丢弃不能被执行的任务

```java
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
}
```

4）`ThreadPoolExecutor.DiscardOldestPolicy`，如果线程池未关闭，则将队列头部的任务丢弃，然后继续执行`execute(Runnable)`方法

```java
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
        e.getQueue().poll();
        e.execute(r);
    }
}
```

### 2.2.3 工厂方法构建的实例

`Executors`的三个方法(没有包含重载方法)返回该类的实例

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
}
/* 构建一个固定容量的线程池，该线程池的线程都是核心线程，任务队列使用无界队列；当线程数达到
corePoolSize时，新提交的任务都将放入队列，这个线程池不会拒绝任务*/


public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
}
/* 构建一个corePoolSize为0，maximumPoolSize无限制的线程池，线程池中的线程都是非核心线程，
当线程空闲超过60s后即被销毁，这个线程池的任务队列使用的是SynchronousQueue，因此一旦提交任务，
即会创建一个线程去执行之*/

public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
}
/* 构建一个corePoolSize = maximumPoolSize = 1的线程池，该线程池只有一个核心线程，任务
队列为无界队列，因此当核心线程已被创建后，所有提交的任务都放入队列，这个线程池不会拒绝任务。与
第一个静态方法不同的是，由于其使用FinalizableDelegatedExecutorService包装
ThreadPoolExecutor，这个线程池一旦初始化，不允许再进行动态配置*/
```

如上所示，前2个静态方法构造的都是特殊的`ThreadPoolExecutor实例`，初始化成功之后，都是可以通过`ThreadPoolExecutor`的实例方法进行动态配置的

第3个静态方法有所不同，其生成了一个容量为1且不可改变的线程池，严格来说，它返回的不是`ThreadPoolExecutor`实例，而是由`ThreadPoolExecutor`包装的`FinalizableDelegatedExecutorService`实例，`FinalizableDelegatedExecutorService`是Executors类（仅具有包访问权限）的内部类，`FinalizableDelegatedExecutorService`类继自`DelegatedExecutorService`，这是一个仅仅有`ExecutorService`接口方法的包装类，因此，当我们调用`newSingleThreadExecutor()`方法时，仅可以将其声明为`ExecutorService`

```Java
ExecutorService service = Executors.newSingleThreadExecutor();

// ！非法，不能强制类型转换
ThreadPoolExecutor pool = (ThreadPoolExecutor)Executors.newSingleThreadExecutor();
```

正因为其是一个仅仅可以执行`ExecutorService`接口方法的包装类，其无法在线程池初始化之后再动态配置


扩展阅读: [ThreadPoolExecutor jdk1.8 Javadoc](//file/ThreadPoolExecutor_doc.pdf)

## 2.4 CompletionService

在提交单个任务时，使用`submit()`或者`execute()`方法或许能够满足要求，但如果需要控制多个任务时，依次提交的操作看起来“有些繁琐”，此时我们可以使用ExecutorService提供的invokeAny/invokeAll方法，在介绍CompletionService接口时，我们不妨先看看这两个方法

之前介绍`AbstractExecutorService`时提到，这两个方法是在这个抽象类中实现的，其中前者在获取到一个任务的返回值时便取消其他（未执行或正在执行的任务）任务，而后者需要等待所有的任务执行完成之后才能对任务的返回进行处理，接下来我们分别来看：

invokeAll会阻塞等待所有的任务执行完成

```java
public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
    throws InterruptedException {
    if (tasks == null)
        throw new NullPointerException();
    ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
    boolean done = false;
    try {
        for (Callable<T> t : tasks) {
            RunnableFuture<T> f = newTaskFor(t);
            futures.add(f);
            execute(f);
        }
        // 有序迭代
        for (int i = 0, size = futures.size(); i < size; i++) {
            Future<T> f = futures.get(i);
            if (!f.isDone()) {
                try {
                    // 阻塞等待任务执行完成
                    f.get();
                } catch (CancellationException ignore) {
                } catch (ExecutionException ignore) {
                }
            }
        }
        done = true;
        return futures;
    } finally {
        if (!done)
            // 处理因异常而未正常执行的任务
            for (int i = 0, size = futures.size(); i < size; i++)
                futures.get(i).cancel(true);
    }
}

// invokeAny
public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
    throws InterruptedException, ExecutionException {
    try {
        return doInvokeAny(tasks, false, 0);
    } catch (TimeoutException cannotHappen) {
        assert false;
        return null;
    }
}
private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,
                          boolean timed, long nanos)
    throws InterruptedException, ExecutionException, TimeoutException {
    if (tasks == null)
        throw new NullPointerException();
    int ntasks = tasks.size();
    if (ntasks == 0)
        throw new IllegalArgumentException();
    ArrayList<Future<T>> futures = new ArrayList<Future<T>>(ntasks);
    ExecutorCompletionService<T> ecs =
        new ExecutorCompletionService<T>(this);

    try {
        // Record exceptions so that if we fail to obtain any
        // result, we can throw the last exception we got.
        ExecutionException ee = null;
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        Iterator<? extends Callable<T>> it = tasks.iterator();

        // Start one task for sure; the rest incrementally
        futures.add(ecs.submit(it.next()));
        --ntasks;
        int active = 1;

        for (;;) {
            // 并没阻塞第一个任务，此时可能第一个任务还未执行完
            Future<T> f = ecs.poll();
            if (f == null) {
                if (ntasks > 0) {
                    --ntasks;
                    // 不等待上一个任务的结果，直接新执行一个任务
                    futures.add(ecs.submit(it.next()));
                    ++active;
                }
                else if (active == 0)
                    break;
                else if (timed) {
                    f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
                    if (f == null)
                        throw new TimeoutException();
                    nanos = deadline - System.nanoTime();
                }
                else
                    // 没有可执行的任务了，则等待一个结果
                    f = ecs.take();
            }
            // 有结果则返回
            if (f != null) {
                --active;
                try {
                    return f.get();
                } catch (ExecutionException eex) {
                    ee = eex;
                } catch (RuntimeException rex) {
                    ee = new ExecutionException(rex);
                }
            }
        }

        if (ee == null)
            ee = new ExecutionException();
        throw ee;

    } finally {
        for (int i = 0, size = futures.size(); i < size; i++)
            // 取消还未执行或者执行中的任务
            // 中断任务
            futures.get(i).cancel(true);
    }
}
```
可以看到，与invokeAll不同的是，invokeAny方法是在循环的启动任务，直到获取到任一任务的返回值为止，而未执行或正在执行的任务则会被中断

下面的示例中，我们修改了[阻塞队列-查找关键字](../生产者-消费者与阻塞队列/#3-1-查找关键字)应用，让任务在成功搜寻到含有关键字的文件时就视为任务完成，取消其他任务的执行，这样一种场景之下，我们可以使用invokeAny方法

```Java
public class Search1Keyword extends SearchKeyword {

    String empty = "";

    public static void main(String[] args) {
        Search1Keyword s1k = new Search1Keyword();
        s1k.find();
    }

    @Override
    void find() {
        // 带资源的try块
        try (Scanner in = new Scanner(System.in)) {
            System.out.print("Enter keyword (e.g. volatile): ");
            keyword = in.nextLine();

            Producer p = new Producer();
            List<Callable<String>> tasks = new ArrayList<>();

            ExecutorService pool = Executors.newCachedThreadPool();

            for (int i = 1; i <= 10; i++) {
                // run consumer
                tasks.add(new Consumer1());
            }
            pool.execute(p);
            // 此方法并不那么单纯，其结果只取一个，但是任务可能执行了多个
            String res = pool.invokeAny(tasks);
            System.out.println(res);
            pool.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    class Consumer1 implements Callable<String> {

        @Override
        public String call() throws Exception {
            try {
                while (!done) {
                    File file = queue.take();
                    if (file == DUMMY) {
                        done = true;
                    } else {
                        String s = search1(file, keyword);
                        if (s.length() > 0) {
                            return s;
                        }
                    }
                }
            } catch (Exception e) {
                // ignore
            }
            return empty;
        }
    }

    public String search1(File file, String keyword) throws FileNotFoundException {
        StringBuilder sb = new StringBuilder("");

        try (Scanner in = new Scanner(file, "UTF-8")) {
            int lineNumber = 0;
            while (in.hasNextLine()) {
                if (!Thread.interrupted()) {
                    lineNumber++;
                    String line = in.nextLine();
                    if (line.contains(keyword)) {
                        sb.append("[").append(Thread.currentThread().getName()).append("]: ")
                            .append(file.getPath()).append(lineNumber).append(line).append("\n");
                    }
                } else {
                    // thread interrupted by future.cancel()
                    System.out.printf("[%s] %s%n", Thread.currentThread().getName(), " interrupted");
                    return empty;
                }
            }
        }
        return sb.toString();
    }
}
/* output (sample1)
Enter keyword (e.g. volatile): take
[pool-1-thread-5]: TestBlockingQueue.java39    LiftOff take() throws InterruptedException {
[pool-1-thread-5]: TestBlockingQueue.java40        return rockets.take();
[pool-1-thread-5]: TestBlockingQueue.java65                    LiftOff rocket = take();
[pool-1-thread-5]: TestBlockingQueue.java78                System.out.println("Interrupted during take()");

[pool-1-thread-11]  interrupted
[pool-1-thread-10]  interrupted
[pool-1-thread-6]  interrupted
[pool-1-thread-4]  interrupted
[pool-1-thread-9]  interrupted
[pool-1-thread-3]  interrupted
[pool-1-thread-7]  interrupted
[pool-1-thread-8]  interrupted

(sample2)
Enter keyword (e.g. volatile): take
[pool-1-thread-4]: Search1Keyword.java66                    File file = queue.take();

[pool-1-thread-2]  interrupted
[pool-1-thread-10]  interrupted
[pool-1-thread-8]  interrupted
[pool-1-thread-5]  interrupted
[pool-1-thread-11]  interrupted
[pool-1-thread-7]  interrupted
[pool-1-thread-9]  interrupted
*/
```
我们将对一个包含关键字的文件进行的完整搜寻视为任务结束，虽然还可能有其他文件还有关键字，但是搜寻任务不再执行。从输出可以看到，输出的只包含一个文件的关键字信息。另外，我们使用10个任务，其中sample1中其他9个任务都被中断，而sample2中只有7个任务被interrupt，说明情况1中，所有的任务都开始执行了，而情况2中，还有未开始执行的任务(其永远不能执行了)

试着思考一个问题，既然invokeAny只需要获取一个任务的返回值即可，那为什么不直接启动第一个任务然后阻塞获取其返回值，而要启动（那么）多任务呢？启动一个任务不是更加简单么？

我们分析源码时，发现invokeAny使用了`ExecutorCompletionService`，这个类继承自接口`CompletionService`，可以用来管理任务提交之后的`Future<T>`对象——将已经完成的Future其放在一个阻塞队列中取用，这样我们就可以回答上面的问题了：

invokeAny利用`ExecutorCompletionService`提交任务，并管理任务的返回，这样可以避免单独启动一个任务而需要阻塞很长时间的弊端，启动的多个任务只要有一个任务完成，其放置已完成Future的阻塞队列将变得可用而使invokeAny快速结束

`ExecutorCompletionService`的快速用法为:

```java
ExecutorCompletionService<T> ecs = new ExecutorCompletionService<>(executor) ;
for(Callable<T> task : tasks){
    ecs.submit(task);
}
for (int i = 0; i < tasks.size() ; i++ ) {
    // get return value
    ecs.take().get();
}
```
# 3 线程池

前文说过，`ThreadPoolExecutor`实例代表了Java线程池，前面我们介绍了`ThreadPoolExecutor`的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭

## 3.1 线程池的运行状态

线程池的运行状态表示了线程池的生命周期，在代码实现中它们使用用一个整数表示

|状态|描述|
|:--:|:--:|
|***RUNNING***|接受新任务的提交，执行队列中的任务|
|***SHUTDOWN***|不接受新任务的提交，执行队列中的任务|
|***STOP***|不接受新任务的提交，不执行队列中的任务，中断正在执行的任务|
|***TIDYING***|所有任务终止，workerCount = 0 ，执行terminated()方法|
|***TERMINATED***|terminated()方法执行完毕|

为了方便地判断线程池的运行状态，给上述线程池状态约定了单调的演化关系：

|状态变化|条件|
|:--:|:--:|
|***RUNNING*** -> ***SHUTDOWN***|调用`shutdown()`方法，或者隐式调用了`finalize()`[^6]|
|(***RUNNING***或***SHUTDOWN***) -> ***STOP***|调用`shutdownNow()`方法|
| ***SHUTDOWN*** -> ***TIDYING***| 当线程池和任务队列都为空时|
|***STOP*** -> ***TIDYING***|线程池为空|
|***TIDYING*** -> ***TERMINATED***|当`terminated()`方法执行完成|

可以看到，线程池的状态是单调演化的，除了RUNNING状态可以接受任务并执行外，其他的状态都将导致线程池资源关闭。`ThreadPoolExecutor`类中有几个获取线程池状态的方法：

```java
/** 若线程池的状态不是RUNNING，那么该方法就返回true*/
public boolean isShutdown() {
    return ! isRunning(ctl.get());
}

/** 若线程池的状态不是RUNNING，并且状态没有还没有切换到TERMINATED，该方法就返回true
这个方法返回true说明线程池正处于terminae的过程中*/
public boolean isTerminating() {
    int c = ctl.get();
    return ! isRunning(c) && runStateLessThan(c, TERMINATED);
}

/** 若线程的状态为TERMINATED，该方法返回true*/
public boolean isTerminated() {
    return runStateAtLeast(ctl.get(), TERMINATED);
}
```

## 3.2 线程池中任务的执行过程

了解了线程池的工作状态，接下来我们尝试去深入任务是如何在线程池中被执行的，以及线程池中核心线程，任务队列以及非核心线程之间是如何协同工作的

在[任务队列](./#任务队列)中，我们阐述了任务队列与线程池之间存在交互关系，这种交互关系体现了线程池执行任务的重要过程

<center  >
<img src = "/img/executor_flow.svg" style= "zoom:0.8;"></img>
</center>
<p style="text-align:center;font-size:.9rem;font-style:italic">线程池执行流程图</p>

上面的流程图展示了任务提交到线程池到执行或被拒绝的过程，和在任务队列中的描述相当，接下来我们从源码的角度阐述这一过程

### 3.2.1 提交任务

在介绍[ExecutorService](./#executorService)时我们提到了AbstractExecutorService基类，它有两个重要的作用：

1. 将所有的任务提交转变为执行一个FutureTask
2. 实现了invokeAny/invokeAll方法

了解到这一点之后，我们将线程池的任务执行重心放在`ThreadPoolExecutor`的`execute(Runnable)`方法上：

```Java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();

    int c = ctl.get();
    // 当前工作线程数 < corePoolSize
    if (workerCountOf(c) < corePoolSize) {
        // 直接添加新的工作线程执行之
        if (addWorker(command, true))
            return;
        // 若新建失败，则表示rs >= shutdown，任务将会被拒绝
        c = ctl.get();
    }
    // 否则将任务放入队列
    if (isRunning(c) && workQueue.offer(command)) {
        // 线程状态RUNNING，任务已放入队列
        // double check
        int recheck = ctl.get();
        // 这里double-check的原因是：
        if (! isRunning(recheck) && remove(command))
            // 1. 线程池可能被shutdown了，这时候直接从队列移除任务并拒绝之
            reject(command);
        else if (workerCountOf(recheck) == 0)
            // 2. 若corePoolSize = 0，而非核心线程都完成了任务
            // 空闲线程超时被销毁之后，就可能出现workerCount = 0 的情况
            // 此时添加一个非核心线程去执行队列中的任务
            addWorker(null, false);
    }
    // 队列满了，则尝试新建一个非核心线程执行任务，否则拒绝之
    else if (!addWorker(command, false))
        reject(command);
}

/**使用Worker包装线程来执行任务*/
private boolean addWorker(Runnable firstTask, boolean core) {
    // 循环判断，直到满足新建Worker的条件为止
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        // 解释一下这个return false的逻辑
        /* 1. 若rs = runnning，继续添加worker
         * 2. 若rs >= shutdown
         *      2.1 rs >= stop 不新建worker(return false)
         *      2.2 rs = shutdown，firstTask != null，不新建worker (shutdown之后不接受新任务提交)
         *      2.3 rs = shutdown，firstTask = null，workQueue为空，不新建worker
         */
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                // 线程数量超限
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        /*
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
        */
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
                // 状态为RUNNING时可以新建Worker执行任务
                // 状态为SHUTDOWN时，任务必须为空(不可提交任务)
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // 调整字段值
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 运行任务
            if (workerAdded) {
                // 从Worker的构造器来看，线程t的构造器参数是Worker
                // 因此start()实际上执行的是Worker的run()方法
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        // 线程池创建线程失败，清理资源
        if (! workerStarted)
            addWorkerFailed(w);
    }
    // 返回true表示线程已创建并启动
    // 根据调用参数的不同，启动的线程可能直接执行任务
    // 也可能从队列中获取任务执行
    return workerStarted;
}
```

<center>
![xx](/img/thread_pool_add_worker.png)
<p style="text-align:center;font-size:.9rem;font-style:italic">线程池添加worker的流程</p>
</center>

### 3.2.2 创建空线程

前面介绍[核心概念](#核心线程池与最大线程池)的时候说到，线程池初始化成功之后，池中是没有活动线程的，不过线程池具有很好的灵活性，可以进行动态配置。使用`prestartCoreThread()`和`prestartAllCoreThreads()`方法可以向线程池中添加**核心**线程，这些线程并没有使用任务初始化，不过其会尝试去队列中获取任务执行，若队列为空，这些线程就会挂起(waiting)[^7]

```java
/** 创建一个核心线程*/
public boolean prestartCoreThread() {
    return workerCountOf(ctl.get()) < corePoolSize &&
        addWorker(null, true);
}
/** 创建所有核心线程*/
public int prestartAllCoreThreads() {
    int n = 0;
    while (addWorker(null, true))
        ++n;
    return n;
}
```

### 3.2.3 执行任务

线程池创建线程是为了执行任务，`addWorker()`方法成功时会启动线程，线程则会调用Worker的`run()`方法

```java
public void run() {
    runWorker(this);
}

/**该方法会循环进行，并且在getTask()方法处阻塞*/
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    // 任务即为创建Worker的入参
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        // 只要有任务提交或队列不为空，则一直执行
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            // 如果线程池状态为STOP（调用shutdownNow()），则中断线程
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                // 可扩展方法
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 可扩展方法
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // while循环结束后的动作
        processWorkerExit(w, completedAbruptly);
    }
}

/** 该方法从队列中获取任务，方法会被阻塞(核心线程)或超时阻塞（非核心线程）*/
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        // 如果状态为SHUTDOWN，但队列不为空，仍从队列中执行任务
        // 如果状态为STOP，则直接return null
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            // workerCount - 1
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        // 当allowCoreThreadTimeOut被设置时，核心线程超时阻塞
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 阻塞队列获取队头任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            // 超时未获取到任务 --> line 79 --> return null
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

<center>
![xx](/img/thread_pool_run_task.png)
<p style="text-align:center;font-size:.9rem;font-style:italic">线程池执行任务的流程的流程</p>
</center>

可以看到，线程池中的线程初始化之后，其执行任务的过程是阻塞的，也就是说，线程池中的线程一直处于“stand by”状态，除此之外，我们还可以得到以下信息：

- 如果没有设置`allowCoreThreadTimeOut`，核心线程执行任务的过程将一直进行
- 非核心线程的执行任务的过程将在超时之后，方法不返回，循环再次进行，将在try块之前的if语句块中返回null
- 当线程池状态为SHUTDOWN时，若队列不为空，仍会去队列中获取任务执行；若状态为STOP，将不会从队列中获取任务

当出现下列任一情况时，`getTask()`会返回null结束线程运行：

1. workerCount > maximumPoolSize，一般在动配置maximumPoolSize之后出现
2. 线程池状态为STOP
3. 线程池状态为SHUTDOWN，且队列为空
4. 当线程获取队列中的任务超时，且该线程不是队列中的唯一线程或队列为空

前面3点都比较好理解，第4点有点难以理解，我们使用一个corePoolSize=0的线程池特例加以说明：

```java
void cachedPool(){
    ThreadPoolExecutor service = (ThreadPoolExecutor) Executors.newCachedThreadPool();

    // service 5秒之后即关闭
    service.setKeepAliveTime(5,TimeUnit.SECONDS);
    service.submit(()->{
        System.out.println("task done");
    });
}
```
我们知道，`newCachedThreadPool`构建一个corePoolSize=0的线程池，因此池中所有的任务在空闲超时都会被超时销毁，我们不妨来看看这一过程是如何发生的；我们将`keepAliveTime`重新设置为5s，并且向线程池中提交一个任务

> 线程池首先会新建一个线程执行任务，调用的是addWorker(firstTask, false)方法；
>
> 在runWorker的第二次循环时，由于firstTask已经被执行，将调用`getTask()`方法去队列中获取任务。我们知道队列中没有任务，超时时间为5s，5s之后getTask()方法将`timeout`置为true后进入第二次循环；
>
> 注意此次循环
>
```Java
if ((wc > maximumPoolSize || (timed && timedOut))
    && (wc > 1 || workQueue.isEmpty())) {
    if (compareAndDecrementWorkerCount(c))
        return null;
    continue;
}
```
>
> 不难看出来，第一次wc =1 并且timeout=false，显然是不满足if的条件；第二次则不同，timeout此时为true，workQueue.isEmpty为true，if条件满足；
>
> 此时将 wc-1，并且返回null

返回null之后，runWorker()方法的while循环也会结束，接下来会执行`processWorkerExit(w, completedAbruptly)`方法

```java
/**while循环正常结束，completedAbruptly为false*/
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 统计已经完成的任务数
        completedTaskCount += w.completedTasks;
        // 将Worker从HashSet中移除
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    // 正如其名，「尝试」终止线程池
    tryTerminate();

    int c = ctl.get();
    // 若线程池状态为RUNNING or SHUTDOWN
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            // 线程池中的最小线程数
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                //队列非空时，要保证池中有线程运行任务
                min = 1;
            if (workerCountOf(c) >= min)
                // 池中还有线程，可以安心返回
                return; // replacement not needed
        }
        // 否则，向池中加入一个线程
        addWorker(null, false);
    }
}
```
在上面方法的最后if条件中，wc=min=0，池中没有线程并且任务队列为空，线程成功完成使命，结束运行

综上所述，被创建的线程除了执行被提交的任务之外，还会被阻塞执行队列中的任务，而核心线程和非核心线程在空闲时又会存在处理方式的差异

值得一提的是，在上面的`newFixedThreadPool()`的例子中，线程池提交完任务之后，并没有调用关闭方法，那么线程池能关闭么？

通过上面的分析，例子中的线程在执行完任务后超时被销毁，此时池中没有线程在运行，队列中也没有任务，**那么就意味着所有的逻辑都已经完成，并没有发生阻塞，线程池中的线程数为0，任务队列为空**，虽然如此，线程池的状态还是***RUNNING***！线程池并没有终止，其还可以继续提交任务运行，实际上，线程池回到了*初始化* 时的状态

## 3.3 如何合理地关闭线程池

`ThreadPoolExecutor`提供了2个关闭线程池的方法

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 检查权限
        checkShutdownAccess();
        // 修改线程池状态为SHUTDOWN
        advanceRunState(SHUTDOWN);
        // 中断所有空闲（waiting）的线程
        // 在condition.await()上阻塞的线程能够响应中断，这就是线程池能够关闭而不阻塞的原因
        // 阻塞的线程被中断唤醒后继续在getTask()上继续执行，在线程池状态判断时return null而结束
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 执行terminated()（空）方法，将线程状态设置为TERMINATED
    tryTerminate();
}

public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 权限检查
        checkShutdownAccess();
        // 修改线程池状态为STOP
        advanceRunState(STOP);
        // 中断所有线程
        interruptWorkers();
        // 队列中未执行的任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}

final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        /*直接返回的条件：
         * 1. 线程池状态为RUNNING
         * 2. 线程池状态为 TIDYING 或 TERMINATED
         * 3. 线程状态为 SHUTDOWN， 且队列不为空
         */
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;
        // 若工作线程数 > 0 , 中断一个空闲线程并返回
        if (workerCountOf(c) != 0) { // Eligible to terminate
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 设置线程池状态为TIDYING
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    // 运行terminated()方法
                    terminated();
                } finally {
                    // 设置线程状态为TERMINATED
                    ctl.set(ctlOf(TERMINATED, 0));
                    // 唤醒awaitTermination方法
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
```

从上面的分析，我们可以清晰地看到`shutdown()`和`shutdownNow()`的区别，前者只中断了空闲线程，后者中断了所有线程；结合前文`getTask()`方法的表述，前者未被中断的线程还可继续执行并从任务队列中获取任务执行，而后者已经无法从队列中获取任务执行了，这与本节开头对线程池的[运行状态](#3-1-线程池的运行状态)的描述一致

`shutdown()`和`shutdownNow()`方法都不能中断正在执行的任务，不过后者对正在执行的任务发送了中断命令，如果任务能够响应中断，即可以作出相应操作。如果想在`shutdown()`或`shutdownNow()`执行之后继续获取任务的返回值，只能使用`awaitTermination()`方法愚蠢地等待。`awaitTermination()`方法阻塞当前调用该方法的线程，直到任务执行完毕、超时、调用线程被中断3者任一条件发生

需要说明的是，如果`awaitTermination()`阻塞过程中线程池的状态变为***TERNMINATD***，说明任务执行完毕，返回true；否则返回false或抛出中断异常

下面的示例代码演示了`shutdown()`和`shutdownNow()`方法的区别

```Java
public class ExecutorShutdown {

    static int pointer = 0;
    /** 容量为1的线程池，其能保证提交的任务都是序列化执行的 */
    ThreadPoolExecutor service = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);

    @SneakyThrows
    public static void main(String[] args) {
        ExecutorShutdown es = new ExecutorShutdown();
        es.shutdown();
//        es.awaitTermination(1, TimeUnit.SECONDS);

    }

    void shutdown() {
        service.execute(new ComplexTask());
        // 对于newFixedThreadPool(1),EasyTask在任务队列中
        service.execute(new EasyTask());
        service.shutdown();
        // shutdown之后，任务并没有执行完成，pointer的值还是0
        System.out.println("pointer:" + pointer);

        // 获取待任务队列
        System.out.println("workQueue: " + service.getQueue());
        // 判断该执行器是否被关闭
        System.out.println("is executor shutdown? " + service.isShutdown());
        // 执行器关闭之后所有任务是否都完成
        // 如果没有调用shutdown()或shutdownNow()就直接调用isTerminated()，该方法必返回false
        System.out.println("is executor terminated? " + service.isTerminated());
        System.out.println("pointer:" + pointer);
    }

    void awaitTermination(int timeout, TimeUnit unit) {
        service.execute(new ComplexTask());
        service.execute(new EasyTask());
        List<Runnable> tasks;
        try {
            if (service.awaitTermination(timeout, unit)) {
                service.shutdown();
            } else {
                if(!(tasks = service.shutdownNow()).isEmpty()){
                    System.out.println("丢弃任务" + tasks);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("workQueue: " + service.getQueue());
        System.out.println("is executor shutdown? " + service.isShutdown());
        System.out.println("is executor terminated? " + service.isTerminated());
    }

    abstract class Task {
        @Override
        public String toString() {
            return getClass().getSimpleName() + "@" + Integer.toHexString(hashCode());
        }
    }

    class ComplexTask extends Task implements Runnable {
        @Override
        public void run() {
            // 响应中断，调用shutdownNow()可以结束任务
            System.out.println("[" + Thread.currentThread() + "@" + this + "]，开始执行");
            // never finish unless interrupted
            for (; ; ) {
                if (!Thread.interrupted()) {
                    pointer++;
                } else {
                    System.out.println("[" + Thread.currentThread() + "@" + this + "]，被中断");
                    break;
                }
            }
        }
    }

    class EasyTask extends Task implements Runnable {
        @Override
        public void run() {
            System.out.println("[" + Thread.currentThread() + "@" + this + "]，开始执行");
            pointer++;
            System.out.println("[" + Thread.currentThread() + "@" + this + "]，执行完成");
        }
    }
}
/* output
调用shutdown：
[Thread[pool-1-thread-1,5,main]@ComplexTask@48d82c9c]，开始执行
pointer:0
workQueue: [EasyTask@14ae5a5]
is executor shutdown? true
is executor terminated? false
pointer:813

调用awaitTermination：
[Thread[pool-1-thread-1,5,main]@ComplexTask@7ac59a98]，开始执行
[Thread[pool-1-thread-1,5,main]@ComplexTask@7ac59a98]，被中断
丢弃任务[EasyTask@7f31245a]
workQueue: []
is executor shutdown? true
is executor terminated? true
*///:~
```
上例中我们设计了一个可以正常执行的任务EasyTask和一个无限循环执行的任务ComplexTask，后者响应中断，如果不中断线程，ComplexTask将一直运行下去。我们使用一个固定容量为1的线程池运行任务，并且先提交ComplexTask，ComplexTask无法结束运行，那么EasyTask将会放入队列中

从运行的结果上来看，使用`shutdown()`无法结束线程池的运行，虽然主线程结束，但线程池一直在后台运行，同时EasyTask也还在任务队列中，主线程结束后线程池的还没有终止，程序会一直在后台运行

当调用`awaitTermination(timeout, unit)`时，很明显这个方法将超时并返回false，最终执行`shutdownNow()`，shutdownNow给ComplexTask任务发送中断命令，其在下一次循环检查到中断，结束执行。同时任务队列中的EasyTask被丢弃，任务队列为空，主线程结束后，线程池也成功终止

如果ComplexTask在设计时，没有响应中断，而使用死循环执行任务，那么`shutdownNow()`方法仍然无法终止线程池，这就是官方文档中关于`shutdownNow()`方法描述的语义：

> *There are no guarantees beyond best-effort attempts to stop
     processing actively executing tasks.  This implementation
     cancels tasks via {@link Thread#interrupt}, so any task that
     fails to respond to interrupts may never terminate.*


[^1]: 表中没有提及关于构建Fork/Join线程池的方法，这部分内容将在后续补全
[^2]: 引自《Java并发编程的艺术》方腾飞等著
[^3]: 须调用合适的构造器，实际上所有参数必须提供，不过有些由构造器默认提供了
[^4]: 本文约定当前工作线程指代线程池中存在的线程（getPoolSize()方法的返回值），其中可能存在部分空闲线程。当工作线程数小于核心线程数时：1）当前线程池中的线程全是核心线程；2）任务队列一定是空的；3）当前某个线程可能是空闲的(执行完任务，在等待队列中的任务（runWorker方法阻塞）)
[^5]: 类似地，存活时间，线程工厂，拒绝策略都可以在线程池初始化之后再进行设置
[^6]: 目前作者还未找到隐式调用`finalize()`方法导致线程池关闭的例证
[^7]: 若corePoolSize=0，这些方法不会创建线程
