---
title: "一些重要的并发组件"
date: 2020-11-16
lastmod: 2020-11-16
draft: false
tags: [Java进阶]
categories: [Java]
author: "wangy325"

hasJCKLanguage: true

weight: 10
mathjax: true
autoCollapseToc: false
---

Java 1.5以后的并发类库新加入了一些用于解决并发问题的新构件，合理地使用这些构件能够帮助我们写出更加简单且健壮的并发程序。本节内容介绍java.util.concurrent包中一些具有代表性的构件，包括

- CountDownLatch
- CyclicBarrier
- Semaphore
- Exchanger
- DelayQueue
- PriorityBlockingQueue


<!-- more-->

# CountDownLatch

在讨论线程的基本概念时，我们说过`join()`方法可使当前线程等待调用join方法的线程执行完，可以实现简单的[无锁同步](../线程基础概念/#9-加入一个线程)，使用CountDownLatch可以更加简单的实现这一目的。毕竟，`join()`方法的语义“加入一个线程”不是很容易就能让人理解。相较于`join()`方法，CountDownLatch的语义就明确多了

在有些文档上，将CountDownLatch译为"倒计时门闩【shuān】"，其维护一个计数器，这个计数器在CountDownLatch初始化之后便**不能重置**。在CountDownLatch上调用`countDown()`方法来将计数值减1，调用这个方法并不会引起阻塞。不过，在这个计数器为0之前，任何调用CountDownLatch的`await()`方法的任务都将阻塞

CountDownLatch的典型用法是将一个任务分割为n个可以独立解决的部分，并创建一个计数器值为n的CountDownLatch，在每个任务完成时，调用`countDown()`方法将计数器减1，在等待所有任务完成的线程上调用`await()`方法，将任务阻塞，知道计数器为0之后再继续运行

下面的代码演示了CountdownLatch的用法

```java
public class CountDownLatchDemo {

    private static class TaskPortion implements Runnable {
        private static int counter = 0;
        private final int id = counter++;
        private static Random rand = new Random(47);
        private final CountDownLatch latch;

        TaskPortion(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void run() {
            try {
                doWork();
            } catch (InterruptedException ex) {
                // Acceptable way to exit
            } finally {
                latch.countDown();
            }
        }

        void doWork() throws InterruptedException {
            TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000));
            System.out.println(this + "completed");
        }

        @Override
        public String toString() {
            return String.format("%1$-3d ", id);
        }
    }

    /** Waits on the CountDownLatch: */
    private static class WaitingTask implements Runnable {
        private static int counter = 0;
        private final int id = counter++;
        private final CountDownLatch latch;

        WaitingTask(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void run() {
            try {
                latch.await();
                System.out.println("Latch barrier passed for " + this);
            } catch (InterruptedException ex) {
                System.out.println(this + " interrupted");
            }
        }

        @Override
        public String toString() {
            return String.format("WaitingTask %1$-3d ", id);
        }
    }

    static final int SIZE = 10;

    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        // 所有任务都必须使用同一个CountDownLatch对象
        CountDownLatch latch = new CountDownLatch(SIZE);
        exec.execute(new WaitingTask(latch));
        for (int i = 0; i < SIZE; i++) {
            exec.execute(new TaskPortion(latch));
        }
        System.out.println("Launched all tasks");
        exec.shutdown(); // Quit when all tasks complete
    }
}
/* output (sample)
Launched all tasks
7   completed
9   completed
5   completed
8   completed
1   completed
2   completed
6   completed
4   completed
0   completed
3   completed
Latch barrier passed for WaitingTask 0  
*///:~
```

上面的示例中，WaitingTask将会阻塞，直到所有的TaskPortion执行完成，TaskPortion完成之后调用了`countDown()`方法，注意，`countDown()`方法是在finally块中调用的，这是为了防止TaskPortion出现异常而导致任务一直阻塞。当计数器为0后，我们看到WaitingTask成功执行

`await()`还有一个重载方法`await(long, TimeUnit)`，避免任务让线程一直等待

# CyclicBarrier

CyclicBarrier被称为“同步屏障”，事实上就可以把它理解为一个屏障，多个任务调用屏障的`await()`方法将被阻塞，直到所有的任务都进入阻塞，那么屏障开启，所有任务继续执行。这看起来和CountDownLatch非常像，不过CountDownLatch只能触发一次，而CyclicBarrier可以多次重用，这是它们的主要区别之一

和CountDownLatch一样，CyclicBarrier接受一个整型参数，表示可限制的线程数。除此之外，CyclicBarrier还可以接受一个Runnable作为参数，这个参数称作`barrierAction`，`barrierAction`在所有线程到达屏障之后即开始执行，其他任务**只能等待**`barrierAction`执行完毕之后才能继续执行，这是CyclicBarrier和CountDownLatch的区别之二

```java
public class TestCyclicBarrier {

    private static StringBuffer sb = new StringBuffer();
    /** CyclicBarrier的构造器任务总是会先执行完毕 */
    static CyclicBarrier c = new CyclicBarrier(2, () -> {
        sb.append(3);
    });
    private static final int ASSERT_VALUE = 312;

    static int run() {
        Thread t = new Thread(() -> {
            try {
                c.await();
            } catch (Exception e) {
                // ignore;
            }
            sb.append(1);
        });
        t.start();
        try {
            c.await();
            sb.append(2);
            t.join();
        } catch (Exception e) {
            // ignore
        }
        return Integer.parseInt(sb.toString()) | (sb.delete(0, sb.length())).length();
    }

    public static void main(String[] args) {

        for (; ; ) {
            int r;
            if ((r = run()) != ASSERT_VALUE) {
                // should be 321
                System.out.println(r);
                return;
            }
        }
    }
}
```

上例中，barrier有一个`barrierAction`和2个“屏障任务”，main方法的输出大概率为312，小概率为321，不会出现其他结果，所以main方法无论执行多长时间，其总会结束。由于`barrierAction`总是先执行，故结果总是3xx[^1]，其先执行完毕的原因在源码中很容易找到：

```Java
//...
// 所有任务到达屏障
if (index == 0) {  // tripped
boolean ranAction = false;
try {
    final Runnable command = barrierCommand;
    //直接在当前线程调用command的run方法
    if (command != null)
        command.run();
    ranAction = true;
    nextGeneration();
    return 0;
    } finally {
        if (!ranAction)
            breakBarrier();
    }
}
//...
```

不过，屏障开启后，任务的执行顺序完全是由cpu调度的。同时，本例中的CyclicBarrier是静态域，在main方法重复执行时，并不会重新初始化，因此也直接证明了CyclicBarrier的可重用性——屏障开启后，任务继续执行后调用屏障的`await()`方法同样会阻塞而等待所有任务到达屏障，以此循环

下例的“赛马游戏”[^2]完美地阐述了CyclicBarrier可以多次重用的特点，马每次跑一步，不过不同的马步长不同，等待所有的马都“跑出这一步”后，屏障开启，先确定是否有马到达终点，如有则结束赛跑，否则继续下一轮，直到有马越过终点线，下面是示例代码

```java
public class HorseRace {

    static class Horse implements Runnable {
        private static int counter = 0;
        private final int id = counter++;
        private int strides = 0;
        private static Random rand = new Random(47);
        private static CyclicBarrier barrier;

        public Horse(CyclicBarrier b) {
            barrier = b;
        }

        public int getStrides() {
            return strides;
        }

        @Override
        public void run() {
            try {
                while (!Thread.interrupted()) {
                    strides += rand.nextInt(3); // Produces 0, 1 or 2
                    barrier.await();
                }
            } catch (InterruptedException e) {
                // A legitimate way to exit
            } catch (BrokenBarrierException e) {
                // This one we want to know about
                throw new RuntimeException(e);
            }
        }

        @Override
        public String toString() {
            return "Horse " + id + " ";
        }

        public String tracks() {
            StringBuilder s = new StringBuilder();
            for (int i = 0; i < getStrides(); i++) {
                s.append("*");
            }
            s.append(id);
            return s.toString();
        }
    }

    static final int FINISH_LINE = 20;
    private List<Horse> horses = new ArrayList<>();
    private ExecutorService exec = Executors.newCachedThreadPool();
    private CyclicBarrier barrier;

    /** 这是一构造器 */
    public HorseRace(int nHorses, final int pause) {
        barrier = new CyclicBarrier(nHorses, () -> {
            StringBuilder s = new StringBuilder();
            for (int i = 0; i < FINISH_LINE; i++) {
                s.append("="); // The fence on the racetrack
            }
            System.out.println(s);
            for (Horse horse : horses) {
                System.out.println(horse.tracks());
            }
            for (Horse horse : horses) {
                if (horse.getStrides() >= FINISH_LINE) {
                    System.out.println(horse + "won!");
                    exec.shutdownNow();
                    return;
                }
            }
            try {
                TimeUnit.MILLISECONDS.sleep(pause);
            } catch (InterruptedException e) {
                System.out.println("barrier-action sleep interrupted");
            }
        });
        for (int i = 0; i < nHorses; i++) {
            Horse horse = new Horse(barrier);
            horses.add(horse);
            exec.execute(horse);
        }
    }

    public static void main(String[] args) {
        int nHorses = 7;
        int pause = 200;
        if (args.length > 0) { // Optional argument
            int n = new Integer(args[0]);
            nHorses = n > 0 ? n : nHorses;
        }
        if (args.length > 1) { // Optional argument
            int p = new Integer(args[1]);
            pause = p > -1 ? p : pause;
        }
        new HorseRace(nHorses, pause);
    }
}
```

实际上程序通过获取每匹马的`strides`域来判断马是否到达终点。在TIJ原书中，对`strides`域的有关操作做了同步处理，而本例中移除了这些同步，这是否安全？虽然CyclicBarrier的`barrierAction`和`HorseRace`都访问了`strides`域，不过，二者访问域的时间一定是错开的：前者在所有马都到达屏障后开始访问，而此时的马处于阻塞状态，而马获得访问权时，`barrierAction`一定没在执行。因此本例中，不使用同步也是安全的

CyclicBarrier还有一些特殊方法

```java
public void reset();
    这个方法将CyclicBarrier重置到初始状态
    注意，这个方法会导致已经在屏障处等待的线程抛出BrokenBarrierException
    如果确实需要一个新的CyclicBarrier来执行操作，新建一个实例是更好的选择

public int getNumberWaiting() ;
    这个方法获取在屏障等待的线程数

public int getParties() ;
    这个方法获取所有的线程数（用来构建CyclicBarrier实例的int入参）
```

下面的例子展示了在任务执行时重置CyclicBarrier的操作，这个示例只是为了展示上面几个方法的用法，**千万不要**在执行任务时贸然去做这样的操作！如果处理不得当将很大可能引发阻塞或其他并发问题

>笔者本意是计划执行批量任务，这些任务有一个域来计算其运行次数，并可能在某个任务上调用`reset()`方法，在`reset()`调用之前和之后的任务其运行次数会有差别，通过这个运行差异在`barrierAction`中来终结线程池。事实上这个预想完全落空了，`reset()`之后，如果不再次使所有线程重新到达屏障处等待，`barrierAction`就不可能执行

```java
public class ResetCyclicBarrier {
    static void reSetBarrierIf(int parties, int bound) {
        TaskMayFail[] tasks = new TaskMayFail[parties];
        ThreadPoolExecutor exec = (ThreadPoolExecutor) Executors.newCachedThreadPool();
        exec.setKeepAliveTime(0, TimeUnit.SECONDS);
        AtomicInteger ai = new AtomicInteger();
        CyclicBarrier c2 = new CyclicBarrier(parties, () -> {
            // if reset barrier while task is running, the
            // barrier action can not reach in this cycle
            // until relaunch all parties to reach at barrier
            // in next round
            int i = 0;
            int r = tasks[i].runtime;
            while (i < parties) {
                if (r != tasks[i].runtime) {
                    System.out.println(tasks[i] + ":" + tasks[i].runtime + ": " + r);
                    exec.shutdownNow();
                    return;
                }
                r = tasks[i].runtime;
                i++;
            }
        });

        for (int i = 0; i < parties; i++) {
            TaskMayFail taskMayFail = new TaskMayFail(c2, ai, bound);
            tasks[i] = taskMayFail;
            exec.execute(taskMayFail);
        }
    }

    private static class TaskMayFail implements Runnable {
        static Random rand = new Random();
        static int count = 1;
        final CyclicBarrier cb;
        final AtomicInteger reSetCount;
        final int bound;
        final int id = count++;
        int runtime = 0;


        public TaskMayFail(CyclicBarrier cb, AtomicInteger reSetCount, int bound) {
            this.cb = cb;
            this.reSetCount = reSetCount;
            this.bound = bound;
        }

        @Override
        public String toString() {
            return "[TaskMayFail-" + id + "-runtime-" + runtime + "]";
        }

        @Override
        public void run() {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    if (rand.nextBoolean()) {
                        // bound值可调整reset的概率
                        if (rand.nextInt(bound) == 0) {
                            throw new ArithmeticException();
                        }
                    }
                    runtime++;
                    cb.await();
                }
            } catch (ArithmeticException ae) {
                reSetCount.incrementAndGet();
                while (cb.getNumberWaiting() < (cb.getParties() - reSetCount.intValue())) {
                    // waiting for all parties reach at barrier
                    // or all parties throws exception
                }
                // reset barrier
                cb.reset();
                System.out.printf("%s-%s reset %s%n",
                    Thread.currentThread().getName(),
                    this,
                    cb);
            } catch (InterruptedException | BrokenBarrierException ae) {
                reSetCount.incrementAndGet();
                // once barrier reset, other parties wait on barrier
                // will throw BrokenBarrierException
                System.out.printf("%s-%s return by broken barrier.%n",
                    Thread.currentThread().getName(),
                    this);
            } finally {
                Thread.currentThread().interrupt();
            }
        }

        public static void main(String[] args) {
            reSetBarrierIf(13, 100);
        }
    }
}
/* output (sample)
pool-1-thread-3-[TaskMayFail-3-runtime-19] reset java.util.concurrent.CyclicBarrier@618bfe9a
pool-1-thread-4-[TaskMayFail-4-runtime-20] return by broken barrier.
pool-1-thread-9-[TaskMayFail-9-runtime-20] return by broken barrier.
pool-1-thread-8-[TaskMayFail-8-runtime-20] return by broken barrier.
pool-1-thread-5-[TaskMayFail-5-runtime-20] return by broken barrier.
pool-1-thread-12-[TaskMayFail-12-runtime-20] return by broken barrier.
pool-1-thread-7-[TaskMayFail-7-runtime-20] return by broken barrier.
pool-1-thread-13-[TaskMayFail-13-runtime-20] return by broken barrier.
pool-1-thread-1-[TaskMayFail-1-runtime-20] return by broken barrier.
pool-1-thread-11-[TaskMayFail-11-runtime-20] return by broken barrier.
pool-1-thread-2-[TaskMayFail-2-runtime-20] return by broken barrier.
pool-1-thread-10-[TaskMayFail-10-runtime-20] return by broken barrier.
pool-1-thread-6-[TaskMayFail-6-runtime-19] reset java.util.concurrent.CyclicBarrier@618bfe9a
*///:~
```
从输出可以看到，CyclicBarrier可以重复使用。上例的设计很巧妙，因为屏障在开启之后，任务可能很快就进入抛出`ArithmeticException`而进入`reset`流程，而此时其他任务可能在屏障处等待或者还未执行，若此时贸然reset，那些等待的线程会抛出`BrokenBarrierException`并退出，但是未执行的线程并未意识到reset的发生（可以这么表述），依然进入阻塞，如果没有再次任务进入`reset`流程，程序很快将因为没有足够多的线程到达屏障而阻塞[^3]。所以，上例引入一个原子变量，用于跟踪进入reset和已经退出的任务数，那么剩余的线程应该就是到达屏障的线程数，利用这个限制来保证**所有的线程都得到处理**，以简化问题的复杂性，一旦确定所有的线程都被处理，就可以执行`reset()`方法。同时`reset()`之后，`barrierAction`便无法执行

# Semaphore

无论是显式锁还是通过synchronized关键字获取的隐式锁，其在任一时刻都只能让一个任务访问资源，而Semaphore（计数信号量）允许多个任务同时访问资源。可以把Semaphore看作是持有对象访问许可（permits）的“security”。访问对象时，须先通过`acquire()`获取许可，若此时没有许可可用，那么`acquire()`将阻塞，否则获取许可，可用许可数-1；使用完资源后，通过`release()`方法返还许可。事实上，并没有实际上的许可证对象，Semaphore通过协同各个线程工作，来达到目的

Semaphore的构造器接受一个“公平性参数”。不传入此参数或传入<i>false</i>时，线程获取许可的顺序无法保证，即使线程阻塞了很久，其仍然可能被刚调用`acquire()`方法的线程“抢走”许可，这可能会导致线程“饿死”。当传入<i>true</i>时，Semphore保证线程获取许可的顺序和其调用`acquire()`方法之后被执行的顺序一致[^4]，也就是先执行的任务先获取许可（FIFO）。需要说明的是，`tryAcquire()`方法不遵循公平性原则，如果有许可可用，它直接获取之。在使用Semaphore时，一般将其设置为**公平**的

Semaphore通常用于限制访问资源的线程数量，典型的例子就是控制“池”的并发访问量。下例中使用Semaphore控制池中的对象方法，当需要使用时，可以将它们“签出”（checkout），使用完毕之后再将其“签入”（checkin），使用泛型类封装功能[^5]

```java
class Pool<T> {
    private final int size;
    final List<T> items = new ArrayList<>();
    private final boolean[] checkedOut;
    private final Semaphore available;

    public Pool(Class<T> classObject, int size) {
        this.size = size;
        checkedOut = new boolean[size];
        available = new Semaphore(size, true);
        // Load pool with objects that can be checked out:
        for (int i = 0; i < size; ++i) {
            try {
                // Assumes a default constructor:
                items.add(classObject.newInstance());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    T checkOut() throws InterruptedException {
        available.acquire();
        return getItem();
    }

    void checkIn(T x) {
        if (releaseItem(x)) {
            available.release();
            System.out.println("release " + x);
        }
    }

    void checkAllIn() {
        available.release(releaseAll());
    }

    private synchronized T getItem() {
        for (int i = 0; i < size; ++i) {
            if (!checkedOut[i]) {
                checkedOut[i] = true;
                return items.get(i);
            }
        }
        // Semaphore prevents reaching here
        return null;
    }

    private synchronized boolean releaseItem(T item) {
        int index = items.indexOf(item);
        if (index == -1) {
            return false; // Not in the list
        }
        if (checkedOut[index]) {
            checkedOut[index] = false;

            return true;
        }
        // Wasn't checked out
        return false;
    }

    private synchronized int releaseAll() {
        int r = 0;
        for (int i = 0; i < items.size(); i++) {
            if (checkedOut[i]) {
                checkedOut[i] = false;
                ++r;
            }
        }
        return r;
    }
}
```

这个池使用`checkout`和`checkIn`方法来签出和签入对象，在签出对象之前调用`acquire()`，如果没有可用对象，那么`checkOut`将阻塞。由于Semaphore的机制，`checkOut`方法并不需要使用同步，但是`getItem`方法则需要同步了，Semaphore协同多线程对资源的访问，但是并不能保证多线程对资源修改的并发安全，这是两回事[^6]。`checkIn`方法则判断给定对象是否被使用，是则签入之，否则不做任何操作，同样的，`releaseItem`方法也需要使用同步

> *The semaphore encapsulates the synchronization needed to restrict access to the pool, separately from
any synchronization needed to maintain the consistency of the pool itself.*

接下来我们可以测试这个池能否正常工作了:

```java
public class SemaphoreDemo {

    private static class AcquireTask<T> implements Runnable {
        private static int counter = 0;
        private final int id = counter++;
        private final Pool<T> pool;

        public AcquireTask(Pool<T> pool) {
            this.pool = pool;
        }

        @Override
        public void run() {
            try {
                T item = pool.checkOut();
                System.out.println(this + " acquire " + item);
            } catch (InterruptedException e) {
                // Acceptable way to terminate
            }
        }

        @Override
        public String toString() {
            return "CheckoutTask-" + id;
        }
    }

    private static class ReleaseTask<T> implements Runnable {
        private static int counter = 0;
        private final int id = counter++;
        private final Pool<T> pool;

        public ReleaseTask(Pool<T> pool) {
            this.pool = pool;
        }

        @Override
        public void run() {
            try {
                List<T> items = pool.items;
                for (T item : items) {
                    pool.checkIn(item);
                }
            } catch (Exception e) {
                // Acceptable way to terminate
            }
        }

        @Override
        public String toString() {
            return "AcquireTask-" + id + " ";
        }
    }

    private static class Fat {
        private volatile double d; // Prevent optimization
        private static int counter = 0;
        private final int id = counter++;

        public Fat() {
            // Expensive, interruptible operation:
            for (int i = 1; i < 10000; i++) {
                d += (Math.PI + Math.E) / (double) i;
            }
        }

        @Override
        public String toString() {
            return "Fat-" + id;
        }
    }

    final static int SIZE = 5;

    private void test() throws InterruptedException {
        final Pool<Fat> pool = new Pool<>(Fat.class, SIZE);
        ExecutorService exec = Executors.newCachedThreadPool();
        for (int i = 0; i < SIZE; i++) {
            exec.execute(new AcquireTask<>(pool));
        }
        exec.execute(new ReleaseTask<>(pool));
        List<Fat> list = new ArrayList<>();
        for (int i = 0; i < SIZE; i++) {
            Fat f = pool.checkOut();
            System.out.println(i + ": main() acquire " + f);
            list.add(f);
        }
        Future<?> blocked = exec.submit(() -> {
            try {
                // Semaphore prevents additional checkout,
                // so call is blocked:
                pool.checkOut();
            } catch (InterruptedException e) {
                System.out.println("checkOut() Interrupted");
            }
        });
        TimeUnit.SECONDS.sleep(2);
        blocked.cancel(true); // Break out of blocked call
        // release all items
        pool.checkAllIn();
        for (Fat f : list) {
            pool.checkIn(f); // Second checkIn ignored
        }
        exec.shutdown();
    }

    public static void main(String[] args) throws Exception {
        SemaphoreDemo semaphoreDemo = new SemaphoreDemo();
        semaphoreDemo.test();
    }
}
/* output(sample)
AcquireTask-0 acquire Fat-0
AcquireTask-4 acquire Fat-4
AcquireTask-3 acquire Fat-3
AcquireTask-2 acquire Fat-2
AcquireTask-1 acquire Fat-1
release Fat-0
0: main() acquire Fat-0
release Fat-1
1: main() acquire Fat-1
release Fat-2
2: main() acquire Fat-2
release Fat-3
3: main() acquire Fat-3
release Fat-4
4: main() acquire Fat-4
checkOut() Interrupted
*///:~
```

上例`SemaphoreDemo`有两个任务，分别用于签入签出对象，程序首先使用`AcquireTask`签出所有对象，接着使用`ReleaseTask`签入对象。主线程接着依次签出所有对象，可以看到，主线程的签出过程是被阻塞的，只有对象签入之后，才能被签出。主线程签出所有对象之后，由于没有签入任务，接着的签出任务一定是被阻塞的，主线程休眠2s后中断了阻塞的任务

# Exchanger

Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，各自拥有一个对象，离开时交换它们拥有的对象。栅栏可以用来设计缓存对象，2个任务分别来使用和清空缓存，当缓存空间满时，则在Exchanger上交换缓存，缓存得以重复使用[^7]

```java
public class DataBuffer<T> {

    private Queue<T> buffer;
    /** 利用size构造一个有界队列 */
    private final int size;

    public DataBuffer(Class<? extends Queue<T>> cls, int size) throws Exception {
        this(cls, size, null);
    }

    public DataBuffer(Class<? extends Queue<T>> cls, int size, Generator<T> gen) throws Exception {
        if (cls == null) throw new NullPointerException();
        // 检查cls的类型，如果不是队列，则抛出异常
        if (!Queue.class.isAssignableFrom(cls)) throw new ClassCastException();
        if (size < 0) throw new IllegalArgumentException();
        this.size = size;
        try {
            Constructor<? extends Queue<T>> c = cls.getConstructor(int.class);
            c.setAccessible(true);
            this.buffer = c.newInstance(size);
        } catch (NoSuchMethodException | SecurityException | InvocationTargetException e) {
            this.buffer = cls.newInstance();
        }

        if (gen != null) {
            for (int i = 0; i < size; i++)
                buffer.offer(gen.next());
        }
    }

    synchronized boolean isFull() {
        return buffer.size() >= size;
    }

    synchronized boolean isEmpty() {
        return buffer.isEmpty();
    }

    synchronized int bufferSize() {
        return buffer.size();
    }

    synchronized public Queue<T> getBuffer() {
        return buffer;
    }

    synchronized boolean addToBuffer(T t) {
        if (!isFull()) {
            return buffer.offer(t);
        }
        return false;
    }

    synchronized T takeFromBuffer() {
        if (!isEmpty()) {
            buffer.remove();
        }
        return null;
    }
}
```

`DataBuffer`接受一个`Queue<T>`类型参数，用来初始化缓存队列，并且利用size指定了缓存队列的容量，作为是“达到栅栏”的前置条件

```java
public class BufferSwap {

    private class FillTask<T> implements Runnable {
        private DataBuffer<T> db;
        private final Exchanger<DataBuffer<T>> ex;
        private final Generator<T> gen;

        public FillTask(DataBuffer<T> db, Generator<T> gen, Exchanger<DataBuffer<T>> ex) {
            this.db = db;
            this.gen = gen;
            this.ex = ex;
        }

        @Override
        public void run() {
            try {
                while (db != null) {
                    if (db.isFull()) {
                        db = ex.exchange(db);
                    } else {
                        db.addToBuffer(gen.next());
                    }
                }
            } catch (InterruptedException e) {
                // right to exit here
            }
        }
    }

    private class EmptyTask<T> implements Runnable {

        private DataBuffer<T> db;
        private final Exchanger<DataBuffer<T>> ex;
        private final int ecLimit;

        public EmptyTask(DataBuffer<T> db, Exchanger<DataBuffer<T>> ex, int limit) {
            this.db = db;
            this.ex = ex;
            this.ecLimit = limit;
        }

        @Override
        public void run() {
            try {
                while (ec.intValue() < ecLimit) {
                    if (db.isEmpty()) {
                        db = ex.exchange(db);
                        ec.incrementAndGet();
                    } else {
                        db.takeFromBuffer();
                    }
                }
            } catch (InterruptedException e) {
                // exit by interrupted
            }
        }
    }

    /** 交换缓存的次数，用来限制程序的运行 */
    private final AtomicInteger ec = new AtomicInteger();

    /**
     * @param size  the buffer size
     * @param limit the exchange time limit
     */
    void test(int size, int limit) {
        Exchanger<DataBuffer<Fat>> xh = new Exchanger<>();
        Generator<Fat> generator = BasicGenerator.create(Fat.class);
        // ignore class check
        // can not solve the issue actually...
        DataBuffer<Fat> fullBuffer, emptyBuffer;
        try {
            fullBuffer = new DataBuffer(ArrayBlockingQueue.class, size, generator);
            emptyBuffer = new DataBuffer(ArrayBlockingQueue.class, size);
        } catch (Exception e) {
            System.out.println("initialization failure");
            return;
        }
        ExecutorService pool = Executors.newCachedThreadPool();
        Future<?> t1 = pool.submit(this.new FillTask(fullBuffer, generator, xh));
        Future<?> done = pool.submit(this.new EmptyTask<>(emptyBuffer, xh, limit));
        for (; ; ) {
            if (done.isDone()) {
                t1.cancel(true);
                break;
            }
        }
        pool.shutdown();
        Queue<Fat> full = fullBuffer.getBuffer();
        System.out.print("fullTask's buffer: ");
        for (Fat fat : full) {
            System.out.printf("%s\t", fat);
        }
        System.out.println();
        System.out.println("++++++++++++++++++++++++++++++++");
        Queue<Fat> empty = emptyBuffer.getBuffer();
        System.out.print("emptyTask's buffer: ");
        for (Fat fat : empty) {
            System.out.printf("%s\t", fat);
        }
    }

    public static void main(String[] args) {
        BufferSwap bs = new BufferSwap();
        bs.test(10, 100);
    }
}
/* output

```




[^1]: 这个示例演化自[《Java并发编程的艺术》方腾飞等.著](https://book.douban.com/subject/26591326/)，第八章8.2节代码清单8-4。不过该书中关于这段代码的运行解释是不正确的，本例也证明了这一点
[^2]: 《Thinking in Java》 4th Edition, 第21章21.7.2示例代码
[^3]: 就算有任务再次进入了reset流程，也依然可能存在上面描述的问题，这仅仅增加了程序运行的不稳定性
[^4]: 并不能保证先调用`acquire()`方法的线程就能先获得许可，而是先调用方法的线程先执行内部逻辑的线程优先获取许可。所以有可能线程a先于线程b调用`acquire()`方法，但是却晚于线程b到达“等待点”
[^5]: 这个示例演化自Semaphore的javaDoc：https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html
[^6]: 如果使用是个“许可证数”为1的Semaphore，其作用相当于一个独占锁，任意时刻只有一个任务能够获取许可并且对资源进行修改，此时，`getItem`方法可以不使用同步
[^7]: 这个示例演化自Exchanger的javaDoc：https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html
