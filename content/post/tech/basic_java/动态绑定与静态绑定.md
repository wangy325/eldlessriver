---
title: "动态绑定与静态绑定—Java基础系列之五"
date: 2020-04-18
lastmod: 2020-05-27
draft: false
tags: [Java基础]
categories: [Java]
author: "wangy325"

hasJCKLanguage: true
# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
postMetaInFooter: false
hiddenFromHomePage: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: false
mathjaxEnableSingleDollar: false
mathjaxEnableAutoNumber: false

# You unlisted posts you might want not want the header or footer to show
hideHeaderAndFooter: false

# You can enable or disable out-of-date content warning for individual post.
# Comment this out to use the global config.
#enableOutdatedInfoWarning: false

flowchartDiagrams:
  enable: false
  options: ""

sequenceDiagrams:
  enable: false
  options: ""
---

这是Java方法调用的2个术语，用来描述Java虚拟机方法调用的2种机制

<!--more-->

## 6.1 <span id = "m10">动态绑定</span>

方法的**名字**和**参数列表**构成了方法的签名

> 返回类型并不是方法签名的一部分，因此在覆盖方法时，允许将导出类的方法返回类型定义为基类返回类型的字类型

方法调用时，虚拟机为每个类创建一个**方法表**，列出所有的方法签名和实际调用的方法，调用方法时按表查找即可，例如方法表可能是这样的：

```
FinalMethod:
	f() -> FinalMethod.f();
	g() -> FinalMethod.g();
	p() -> FinalMethod.p();
	// skip Object method...
FinalMethodExt
	f() -> FinalMethodExt.f();
	p() -> FinalMethodExt.p();
	// skip Object method...
```

当对象引用`o`调用方法时，其过程可归纳为：

- 虚拟机提取`o`的**实际类型**的方法表
- 在方法表中搜索调用的方法，若有满足，则直接调用
- 若无满足，则在`o`实际类型的父类中搜索调用的方法
- 调用方法或抛出异常

从上面的描述可以看出，继承体系中的方法调用可能出现不同的结果（导出类覆盖和未覆盖基类方法时的差异现象）

## 6.2 静态绑定

当方法被`private`，`static`，`final`修饰或调用构造器（构造器可看作是`static`方法）的时候，编译器即可准确的知道该调用哪个类的哪个方法，这一过程就是**静态绑定**


