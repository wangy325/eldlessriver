---
title: "2的补码问题"
date: 2019-07-17
draft: false
tags: []
categories: [计算机]
author: "wangy325"

hasJCKLanguage: true
# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
# comment: false
toc: true
autoCollapseToc: false

# reward: false
---

一直以来，关于2进制的讨论只出现在位运算里，并且也结束在位运算这里。所以，关于**如何在计算机中表示一个负数**这样的问题的讨论很少，也常被忽略遗忘。

<!--more-->

在经历了几次google为什么要使用补码之后，我决定将其markdown，希望能记得牢靠。

#### 2的补码(2's Complement)表示负数

高位是符号位，1表示负数；如果求一个数的负数，那么对其`取反加1`即可。这是关于计算机中负数的最常见表述。

> 假如我们定义数的长度为8位，那么负数如何求得与表示呢？
> 例如十进制数6的负数在计算机内先对`0000 0110`进行取反得到`1111 1001`,再对其加1得到`1111 1010`，即：
>
> ```js
> ~(0b00000110) + 1 = 0b11111010
> //等价于
> -7 + 1 = -6
> ```

可以验证，对于负数（转换为正数），`取反加1`的口诀也是适用的。

#### 为什么使用2的补码

> 要明确一点：计算机内部用什么方式表示负数，其实是无所谓的。只要能够保持一一对应的关系，就可以用任意方式表示负数。所以，既然可以任意选择，那么理应选择一种最方便的方式。

使用2的补码，**加法运算可以使用同一种电路完成**

假如我们直观上认为负数以高位为1表示，那么，十进制-6就表示为：`1000 0110`，我们尝试用2种表示法去做一个12 + (-6)的运算：

```
  0000 1100 
+ 1000 0110
------------ -
  1001 0010
```

上面的结果表示，使用更加易读的方式来表示负数的话，运算的结果将显示为一个负数（-18），这表明，若采用此种方法表示负数，那么就要为正负数分别设置一套加法运算规则，即**两种计算电路**。

接下来，使用2的补码形式进行计算：

```
  0000 1100
  1111 1010
-------- ---
1 0000 0110
```

可以看到，使用2的补码形式计算12+(-6)，得到的是一个9位表示的数，在定义为8位机的前提下，9位最高位是**溢出**的，会自动舍除，因此得到的结果是6。

从上面的例证可以看出，使用补码的形式来表示负数，可以简化运算规则的设计。

#### 为什么2的补码要取反加1

尝试去思考一个问题：为什么2的补码要取反+1，或者说，为什么取反+1叫2的补码？

通常来讲，要求一个值的负数，只需要用0减就可，如`0-6 = -6`，那么，在计算机中，是否可以这样操作呢？我们可以作如此假设：

> 在计算机中，0-6同样需要*向高位借位*，高位为1的情况下，`00000000`实际上可以看作是`100000000`，那么，0-6的计算式则可以表示为：
>
> ```
>  1 0000 0000
> -  0000 0110
> ------------- --
>    1111 1010
> ```
>
> 进一步，如果将`100000000`看作`11111111+1`的话，那么上述算式即可表示为：
>
> ```
>   1111 1111
> - 0000 0110
> --------- ---
>   1111 1001
> ```
>
> 将上式结果+1，即`11111001 + 1 = 11111010`
> 观察发现,`11111111 - 00000110`实际上就是`00000110`取反，故求**2的补码**的操作和对该操作数**取反加1**，获得的结果是一样的。

#### 使用2的补码可以完成对整数集的运算吗

前面提到，使用2的补码进行加法运算的时候，如果使用更加直观的表示负数的方法，进行形如18+(-6)的运算，得到的结果是不能按照当前约定的规则解释的。

那么，使用2的补码进行形如上述运算，正确性能扩展到整数集么？我们尝试去证明 ：

> ```
> X +（-Y）= X + (11111111 - Y +1)
> ```

令`Z=X+(-Y)`， `Z'=X+(11111111-Y+1)`， 即`Z'=X+(-Y)+11111111+1`；

1）当X>Y时，Z>0，此时`Z‘=Z+11111111+1`，由于我们规定8位机，因此`11111111+1=100000000`的高位溢出舍去，即得`Z'=Z`；

2）当X<Y时，Z<0，`Z‘=Z+11111111+1` ==> `Z‘=-(-z)+11111111+1` ==> `Z'=-(11111111-z+1)+11111111+1` ==> `Z'=Z`；

由上述论证可以得出，使用2的补码表示负数是可靠的。

#### 参考

- [关于2的补码-ruanyf](http://www.ruanyifeng.com/blog/2009/08/twos_complement.html)