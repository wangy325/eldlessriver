---
title: "集合框架—Java基础系列之十"
date: 2020-04-29
lastmod: 2020-05-27
draft: false
tags: [Java基础]
categories: [Java]
author: "wangy325"

hasJCKLanguage: true

weight: 10
mathjax: true
autoCollapseToc: false

---

本文系统讲解了常见的集合框架实现，所有实现都是**线程不安全**的

<!--more-->

![JXUL1s.png](https://s1.ax1x.com/2020/05/01/JXUL1s.png)

<p style="text-align:center;font-style:italic;font-size:.9rem">Java集合框架简图</p>

> 1. 未列出枚举集（EnumSet/EnumMap）
> 2. 未列出IdentityHashMap
> 3. 未列出java.util.concurrent包下的实现


## 11.1 List

List是**有序集合**，或称之为**序列**。List的实现可以准确地控制插入元素的位置，也可以通过元素的**索引**(*index*)访问之，还可以在集合中搜索元素

和[Set](#set)不同，List允许元素重复出现，甚至允许多个null元素出现

List定义了4个由索引执行的操作

> E get(int index);
>
> E set(int index, E element);
>
> void add(int index, E element);
>
> E remove(int index);

ArrayList由于实现了`RandomAccess`接口，其在使用索引随机访问时性能不会受影响，但是LinkedList执行索引操作的耗时是与集合大小正相关的。因此，在不清楚List的实现类型的时候[^7]，通**过迭代器遍历集合中的元素进行操作比直接使用索引更可取**

List提供了一个独有的迭代器***ListIterator***，其提供了插入/替换元素的操作，并且支持**双向迭代**

###  11.1.1 ArrayList

ArrayList是Java集合框架中使用最为频繁的实现，其本质是一个**有序的**可自由扩容的**对象数组**。它实现了`RandomAccess`这个**标记接口**，意味着其在随机访问性能上有一定优势

下图显示了ArrayList的继承关系

![JIvHtH.png](https://s1.ax1x.com/2020/04/29/JIvHtH.png)

<p style="text-align:center;font-style:italic;font-size:.9rem">ArrayList继承关系</p>

#### 11.1.1.1 初始化及扩容机制

ArrayList初始化为一个空的对象数组，如果**不在构造对象时指定初始容量大小，那么ArrayList的默认初始化一个容量为10的对象数组**，其扩容规则是每当新增加对象超出对象数组的容量时，将对象数组的容量**增加当前容量的1/2**

参考如下示例：

```java
static void initializeTest() throws NoSuchFieldException, IllegalAccessException {
  List<Integer> list = new ArrayList<>();
  // initial size = 10

  for (int i = 0; i <16; i++){
    list.add(new Random().nextInt(100));
    // 本体是elementData
    Field field = list.getClass().getDeclaredField("elementData");
    field.setAccessible(true);
    // 获取list的“elementData”
    Object[] o = (Object[]) field.get(list);
    // size是ArrayList的长度，length是elementData的长度
    System.out.println("size = " + (i+1) + ",
                       length = " + o.length + " ,
                       element = " + Arrays.toString(o));
   }
}
/* output:
size = 1, length = 10 ,element = [15, null, null, null, null, null, null, null, null, null]
size = 2, length = 10 ,element = [15, 15, null, null, null, null, null, null, null, null]
size = 3, length = 10 ,element = [15, 15, 31, null, null, null, null, null, null, null]
size = 4, length = 10 ,element = [15, 15, 31, 40, null, null, null, null, null, null]
size = 5, length = 10 ,element = [15, 15, 31, 40, 47, null, null, null, null, null]
size = 6, length = 10 ,element = [15, 15, 31, 40, 47, 26, null, null, null, null]
size = 7, length = 10 ,element = [15, 15, 31, 40, 47, 26, 47, null, null, null]
size = 8, length = 10 ,element = [15, 15, 31, 40, 47, 26, 47, 41, null, null]
size = 9, length = 10 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, null]
size = 10, length = 10 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, 69]
size = 11, length = 15 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, 69, 32, null, null, null, null]
size = 12, length = 15 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, 69, 32, 94, null, null, null]
size = 13, length = 15 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, 69, 32, 94, 25, null, null]
size = 14, length = 15 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, 69, 32, 94, 25, 11, null]
size = 15, length = 15 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, 69, 32, 94, 25, 11, 80]
size = 16, length = 22 ,element = [15, 15, 31, 40, 47, 26, 47, 41, 91, 69, 32, 94, 25, 11, 80, 86, null, null, null, null, null, null]
///:~
```

ArrayList的内容存储在`elementData`对象数组中，通过在运行时获取对象信息，能够窥视ArrayList的初始化过程：

- `elementData`初始化为容量默认为10，内容为空的对象数组`new Object[10] = {}`

- 添加第10个元素时，此时`elementData`的容量也是10，无法容纳更多元素，需扩容，源码所见：

  ```java
  if (minCapacity - elementData.length > 0){
    int oldCapacity = elementData.length;
    // 扩容
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
      newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
      newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
  }
  ```

  扩容方式为将容量增加一半

- 使用`Arrays.copyOf()`方法将`elementData`重新引用至新的拷贝数组——这一过程去尾

#### 11.1.1.2 迭代器

集合框架的继承关系图显示，Collection接口继承了 *Iterable* 接口，这意味着所有的集合实现都**可以使用迭代器**操作集合

作为使用最广的集合实现，ArrayList可以获取 *Iterator* 和 *ListIterator* 的实现，后者继承了前者，在前者的基础上新增了一些用于可逆迭代（ *cursor在集合中来回穿梭* ）的特性，如`previous()`，`previousIndex()`等方法

![JoCR9e.png](https://s1.ax1x.com/2020/04/29/JoCR9e.png)

<p style="font-size:.9rem; text-align:center;font-style:italic">迭代器方法表</p>

下面代码简单展示了迭代器的使用：

```java
static void iteratorTest() {
  List<String> a = new ArrayList<String>() {{
    add("apple");
    add("google");
    add("amazon");
    add("cisco");
    add("facebook");
    add("twitter");
  }};
  Iterator<String> iterator = a.iterator();
  a.remove(2);
  // throw ConcurrentModificationException
  //        System.out.println(iterator.next());
  // 重新获取迭代器，避免上述异常
  Iterator<String> newIterator = a.iterator();
  newIterator.next();
  // Java 8新增方法，迭代剩余元素
  newIterator.forEachRemaining(s -> {
    s= s.replaceFirst("g","G");
    System.out.println(s);
  });
}
/* output:
Google
cisco
facebook
twitter
///:~
```

```java
static void listIteratorTest() {
  ListIterator<String> listIterator = a.listIterator();
  listIterator.next();
  // do not change cursor
  listIterator.set("Apple");
  listIterator.previous();
  while (listIterator.hasNext()) {
    System.out.println(listIterator.next());
  }
  System.out.println("-------");
  // cursor changed
  listIterator.remove();
  listIterator.add("TWITTER"); // cursor in the end
  // reverse output
  while (listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
  }
}
/* output:
Apple
google
twitter
-------
TWITTER
google
Apple
///:~
```

关于**集合的迭代器**[^1]，作如下说明：

1 当集合和迭代器持有的“计数器”不一致时，迭代器的 *ConcurrentModificationException* 出现：

计数器：记录发生集合**结构性变化**的次数，一般指集合元素增删，更新集合元素值一般不会被视作结构性				变化[^2]；迭代器也维护一个计数器，此数字初始化为原集合计数器的值

需要记住的是，迭代器的计数器只能通过迭代器维护（ *调用迭代器的add()，remove()等方法会更新计数器* ），而集合的计数器却可以通过迭代器和集合维护，亦即通过迭代器更新的计数器会同步更新集合的计数器（ *因为迭代器方法也是通过集合方法实现的* ）；**反之不亦然**，记住，在获取迭代器之后，在使用**集合而非迭代器**的方法修改集合结构，那么迭代器会发生异常（ *2个计数器值不一致* ）

参考ArrayList.Itr.remove()[^3]源码：

```java
public void remove() {
  if (lastRet < 0)
    throw new IllegalStateException();
  checkForComodification();

  try {
    ArrayList.this.remove(lastRet);
    cursor = lastRet;
    lastRet = -1;
    // 更新计数器
    expectedModCount = modCount;
  } catch (IndexOutOfBoundsException ex) {
    throw new ConcurrentModificationException();
  }
}
final void checkForComodification() {
  // 一致性检查
  if (modCount != expectedModCount)
    throw new ConcurrentModificationException();
}
```



2 不论是 *Iterator* 或 *ListIterator* 接口在Java集合框架中都没有**独立的实现类**，都是作为**集合具体实现的内部类**存在的，这种机制使得不同的集合类型，拥有“定制”的迭代器类型，这意味着方法表并不是一成不变的，如ArrayList.ListIterator就缺失`hasNext()`方法

<img src="https://s1.ax1x.com/2020/04/27/JfiSYj.png" alt="JfiSYj.png"  />

<p style="text-align:center;font-style:italic;font-size:.9rem"><span id="llterator">LinkedList</span>(左)和ArrayList(右)内部ListIterator的实现差异</p>

这种只定义接口**而使用内部类实现**的现象在Java集合框架中非常常见，理解这一点有利于理解**集合视图**( *Collection view* )，接下来这个概念将多次出现

按照理论，ListItr实现了ListIterator接口应该覆盖所有方法，Intellij IDEA编译器对于ArrayList的内部类ListItr给出了 *method should be defined since the class is not abstract*的批注，这或许是Java源码的豁免权

实际上，ArrayList.ListItr继承了ArrayList.Itr，因此，ListItr缺失的方法由Itr实现了

3 Java 8的改进

Java 8 新增的**函数式接口**，在集合框架中得到广泛使用，关于Java 8对集合框架的优化，后文将单独说明

在迭代器 *Iterator* 接口中，新增了一个方法

```java
default void forEachRemaining(Consumer<? super E> action) {
 Objects.requireNonNull(action);
 while (hasNext())
   action.accept(next());
}
```

这是一[默认方法](#default_method)，其接受一个 *Consumer* 参数，用来对元素执行操作，需要注意的是此迭代器的指针( *cursor* )并不是0，而是当前实际的指针，亦即此法用于**迭代还未被此迭代器迭代的元素**

#### 11.1.1.3 SubList

SubList是ArrayList的内部类，是方法`subList(int fromIndex, int toIndex)`的返回对象，也就是说，ArrayList.subList()的返回**不是一个ArrayList实例**，而是一个**视图**

所谓**集合视图**，可以通俗的理解为集合的内部类[^5]，如此Sublist，其一个主要的特点是**可以更改原集合**（作用可以理解为原集合的一个代理）

```java
private class SubList extends AbstractList<E> implements RandomAccess {
  //...
}
```

SubList可以看作一个"类ArrayList"，方法也有很多共性，而往往只需要注意差异即可

参考下例：

```java
static void subListTest(){
  List<String> a = new ArrayList<String>() {{
    add("apple");
    add("google");
    add("amazon");
    add("cisco");
  }};
  List<String> strings = a.subList(1, 2); // [google]
  System.out.println("Is subList instance of ArrayList? "
                     + (strings instanceof ArrayList)
                     + "\n-------");
  // a.add("Java") // ERROR! cause ConcurrentModificationException for subList
  ListIterator<String> subIterator = strings.listIterator();
  while (subIterator.hasNext()){
    subIterator.set(subIterator.next().toUpperCase() + " revised by subList");
  }
  // 增加元素
  subIterator.add("foobar added by subList");
  a.forEach(System.out::println);
  // 删除子集，父集也删除元素
  strings.clear();
  System.out.println("-------");
  a.forEach(System.out::println);
}
/* output:
Is subList instance of ArrayList? false
-------
apple
GOOGLE revised by subList
foobar added by subList
amazon
cisco
-------
apple
amazon
cisco
///:~
```

之所以将其称为**视图**，一个很重要的原因就是，这个类所有**有利数据**全部来自外围类(ArrayList)，其能够修改外围类的能力来自于**直接对外围类方法的调用**[^11]：

```java
public void add(int index, E e) {
  rangeCheckForAdd(index);
  checkForComodification();
  // 实际上调用的就是外围类的方法
  parent.add(parentOffset + index, e);
  this.modCount = parent.modCount;
  this.size++;
}
```

实际上，可以将SubList理解为ArrayList实用工具的巧妙封装

> 和迭代器一样，获取SubList之后，对原集合进行结构性改变，也会引起*ConcurrentModificationException*

#### 11.1.1.4 插入与删除

前文提到，尽管ArrayList因实现了Random接口而具有很好的随机读取性，ArrayList也有一些缺点，比如**差强人意的插入和删除**

ArrayList方法：

```java
public void add(int index, E e) {...}
public E remove(int index) {...}
public boolean remove(Object o) {...}
...
```

实现了从插入集合到指定索引为止或从集合中删除（指定索引）元素，但这些操作并不是ArrayList的强项，拿`add(int index, E e)`为例：

```java
public void add(int index, E element) {
  rangeCheckForAdd(index);

  ensureCapacityInternal(size + 1);  // Increments modCount!!
  // 拷贝数组--实际上是将数组index位置以后的所有元素”后移一位“
  System.arraycopy(elementData, index, elementData, index + 1,
                   size - index);
  elementData[index] = element;
  size++;
}
```

同理，从ArrayList的删除相关方法中也可以看到类似的操作，这意味着在操作大量数据的时候，ArrayList可能会遇到性能问题。在对象数组长度很小时，这种影响一般可以忽略

### 11.1.2 LinkedList

LinkedList是基于**链表**的有序集合，~~其不能像ArrayList一样通过索引(*index*)访问元素~~，同时LinkedList还实现了双端队列Deque接口，意味着LinkedList可以**实现队列的操作**

![JIv7Ae.png](https://s1.ax1x.com/2020/04/29/JIv7Ae.png)

<p style="text-align:center;font-style:italic;font-size:.9rem">LinkedList继承关系图</p>

链表将每个对象存放在独立的节点(Node)中，节点中还保存对序列中前、后节点的引用。理论上，LinkedList**没有容量限制**

![J4sq7d.png](https://s1.ax1x.com/2020/04/28/J4sq7d.png)

<p style="text-align:center;font-style:italic;font-size:.9rem">LinkedList的基本数据结构<sup>  from Core Java</sup></p>

#### 11.1.2.1 Node

**Node（节点）**是LinkedList的存储载体，每向LinkedList中增加/删除一个元素，就会增加/减少一个Node，Node定义了3个字段，其含义分别是：

> E item：存入LinkedList的内容
>
> Node\<E\> prev：前一个节点的引用
>
> Node\<E\> next：后一个节点的引用

结合LinkedList的字段来看，LinkedList定义了两个个Node相关的引用：

> transient Node\<E\> first：总是指向LinkedList的第一个节点
>
> transient Node\<E\> last：总是指向LinkedList的最后一个节点

LinkedList有如下规律：

1. `first.prev`总是为null
2. `last.next`总是为null
3. 当LinkedList只有一个元素时，`first == last`

下面的代码验证了上述推论：

```java
static void initializeTest() throws Exception {
  List<String> a = new LinkedList<>();
  a.add("google");
  //        a.add("chrome");
  //        a.add("photos");

  Class<?> cls = LinkedList.class;
  // LinkedList field
  Field ff = cls.getDeclaredField("first");
  Field lf = cls.getDeclaredField("last");
  ff.setAccessible(true);
  lf.setAccessible(true);
  Object first =  ff.get(a);
  Object last = lf.get(a);
  Class<?> node = Class.forName("java.util.LinkedList$Node");
  // LinkedList$Node field
  Field item = node.getDeclaredField("item");
  Field next = node.getDeclaredField("next");
  Field prev = node.getDeclaredField("prev");
  item.setAccessible(true);
  next.setAccessible(true);
  prev.setAccessible(true);
  // first
  System.out.println("first: " + first);
  Object firstItem = item.get(first);
  Object firstPrev = prev.get(first); // Node
  Object firstNext = next.get(first); // Node
  System.out.println("\t" + "item: " + firstItem +"\n\t" +
                     "prev: " + firstPrev + "\n\t" +
                     "next: " + firstNext + "\n");
  // last
  System.out.println("last: " + last);
  Object lastItem = item.get(last);
  Object lastPrev = prev.get(last);
  Object lastNext = next.get(last);
  System.out.println("\t" + "item: " + lastItem +"\n\t" +
                     "prev: " + lastPrev + "\n\t" +
                     "next: " + lastNext);
}
/* output:
first: java.util.LinkedList$Node@512ddf17
	item: google
	prev: null
	next: null

last: java.util.LinkedList$Node@512ddf17
	item: google
	prev: null
	next: null

// 当有3个元素时，first的next == last的prev
first: java.util.LinkedList$Node@512ddf17
	item: google
	prev: null
	next: java.util.LinkedList$Node@2c13da15

last: java.util.LinkedList$Node@77556fd
	item: photos
	prev: java.util.LinkedList$Node@2c13da15
	next: null
///:~
```

利用Node，对链表中的元素的删除和插入操作将变得便利，只需要同时修改自身及前后节点的引用即可将元素置入链中

参考如下源码：

```java
/**
 * Inserts element e before non-null Node succ.
 */
void linkBefore(E e, Node<E> succ) {
  // assert succ != null;
  final Node<E> pred = succ.prev;
  final Node<E> newNode = new Node<>(pred, e, succ);
  succ.prev = newNode;
  if (pred == null)
    first = newNode;
  else
    pred.next = newNode;
  size++;
  modCount++;
}
```

上述源码解释了如何将一个新的元素插入到链表中

#### 11.1.2.2 迭代器

LinkedList没有 *Iterator* 的实现，只有 *ListIterator* 的实现，里面定义了相当充分的[操作元素的方法](#llterator)，由于LinkedList也是List的实现类，故也可调用接口定义的`iterator()`方法[^4]，不过其实际上返回的是 *LinkedList.ListIterator* 实例

![JoCYkT.png](https://s1.ax1x.com/2020/04/29/JoCYkT.png)

<p style="font-size:.9rem;font-style:italic;text-align:center">LinkedList调用iterator()的时序图</p>

尽管如此，由于使用`LinkedList.iterator()`方法返回的是Iterator，其对集合的操作性降低到只有4个方法。由于我们知道其实际返回的是Listiterator，我们可以将该返回值**向下转型**：

```java
ListIterator<String> i = (ListIterator<String>) list.iterator();
// 等价于
ListIterator<String> listIterator = list.listIterator();
// 等价于
ListIterator<String> listIterator1 = list.listIterator(0);
```

参考如下示例：

```java
static void iteratorTest(){
  List<String> list = new LinkedList<String>(){{
    add("Java");
    add("Python");
    add("JavaScript");
    add("C");
  }};
  ListIterator<String> i = (ListIterator<String>) list.iterator();
  while (i.hasNext()){
    if (i.next().equals("JavaScript")){
      i.set("JS");
    }
  }
  i.remove();
  i.add("C++");
  // 反向迭代
  while (i.hasPrevious()){
    System.out.println(i.previous());
  }
  System.out.println("-------");
  ListIterator<String> iterator = list.listIterator(2);
  iterator.forEachRemaining(System.out::println);
}
/* output:
C++
JS
Python
Java
-------
JS
C++
///:~
```

> ListIterator<E> listIterator(int index); 
>
> 此方法用于获取 *index* （含）之后的元素的迭代器

#### 11.1.2.3 对比ArrayList

ArrayList的优势在于可以利用 *index* 快速访问集合中的元素，劣势在于对于容量大的集合，插入和删除的效率稍低

LinkedList基于链表，~~插入和删除操作效率高~~<sup>并不总这样</sup>；但由于没有元素索引( *index* )，使用`get(int index)`和`set(int index , E e)`的效率稍低[^6]

在LinkedList中，和索引相关的操作有：

> public E get(int index)
>
> public E set(int index, E element)
>
> public void add(int index, E element)
>
> public E remove(int index)
>
> public int indexOf(Object o) 	获取对象首次出现的位置
>
> public int lastIndexOf(Object o)	获取对象最后出现的位置

除了`indexOf`和`lastIndexOf`方法之外，其他的四个方法的实现都和这个方法有关：

```java
public void add(int index, E element) {
  checkPositionIndex(index);

  if (index == size)
    linkLast(element);
  else
    linkBefore(element, node(index));
}
/**
 * Returns the (non-null) Node at the specified element index.
 */
Node<E> node(int index) {
  // assert isElementIndex(index);

  if (index < (size >> 1)) {
    Node<E> x = first;
    for (int i = 0; i < index; i++)
      x = x.next;
    return x;
  } else {
    Node<E> x = last;
    for (int i = size - 1; i > index; i--)
      x = x.prev;
    return x;
  }
}
```

可以看到，`node(int index)`**总是从头/尾开始逐一遍历**，当集合较大时，这种操作的效率是很低的

既然如此，LinkedList**插入和删除的效率如何高**呢？答案就是**使用迭代器**，由于迭代器持有指针(*cursor*)，**免去了遍历集合获取节点的时间消耗**，因而插入和删除只需要修改前后节点的引用即可：

![JTEuRK.png](https://s1.ax1x.com/2020/04/29/JTEuRK.png)

<p style="text-align:center;font-size:.9rem;font-style:italic">从LinkedList删除一个元素<sup> from Core Java</sup></sup></p>

> 所以，不要在LinkedList中使用带有索引(*index*)参数的操作，这会大大降低程序的运行效率，若要使用索引，请使用ArrayList

#### 11.1.2.4 作为双端队列

LinkedList除了实现了List接口之外，还实现了Deque接口，也就是说，**LinkedList还是一个双端队列**

## 11.2 Queue

![J7NBrQ.png](https://s1.ax1x.com/2020/04/29/J7NBrQ.png)

<p style="text-align:center;font-size:.9rem;font-style:italic">Queue继承关系简图</p>

Queue（队列），实际开发过程中，在单线程环境下使用的情况下不多，Queue作为集合框架中重要组成似乎习惯性被忽略，队列总是先持有元素，再处理元素<sup>?</sup>

> *A collection designed for holding elements prior to processing* 

除了Collection定义的操作之外，Queue定义了额外的插入/删除/检查元素的操作，这些操作有2种形式：

|             | *Throws Exception* | *Returns special value* |
| :---------: | :----------------: | :---------------------: |
| **Insert**  |       add(e)       |        offer(e)         |
| **Remove**  |      remove()      |         poll()          |
| **Examine** |     element()      |         peek()          |

如表所示，add/remove/element方法失败后抛出异常。offer/poll/peek方法失败后返回一个特殊值（null或false，视具体操作不同），需要说明的是，`offer()`方法主要是为**有容量限制的队列**设计的

典型的队列遵从FIFO( *first-in-first-out* )原则，FIFO队列的新元素总是插入到队尾

当然有例外，**PriorityQueue**就是之一，它根据给定（或默认）的比较器决定元素顺序；此外还有LIFO( *last-in-first-out* )队列（如栈）

不管是何种队列，都可以使用`remove()`或`poll()`**移除并返回**队列头元素，至于头元素是“谁”就由队列的排序规则决定。此二者的区别体现在当队列为空时，`remove()`抛出异常，而`poll()`返回`null`

`element()`和`peek()`**获取但不移除**队列头元素，区别在于当队列为空时，`element()`抛出异常，而`peek()`返回`null`

`offer()`方法尝试向队列中插入一个元素，否则返回`false`，而`Collection.add`方法失败之后会抛出（运行时）异常。因此`offer()`方法适用于定容或有界队列中插入元素

队列中不允许插入`null`，或者说**不应**将`null`插入队列中（LinkedList允许空值），因为`null`会作为队列方法的特殊返回值（空队列指示器）出现，若将`null`抽入队列，会引发歧义

**Queue有两个子接口：**

1. BlockingQueue

   Queue中并没有定义**阻塞队列**的相关方法，阻塞队列通常在**并发编程**中使用。阻塞队列的方法会等待元素出现或（有限）集合空间可用这2个条件之一满足才执行

2. Deque 

   **双端队列**是支持从**队首和队尾添加/删除元素**的线性集合，一般来说，Deque**没有容量限制**，但是其也支持有限长度的实现

   Deque定义了支持从双端访问元素的方法，和Queue一样，方法作用有3，形式有2:
   
   <table BORDER CELLPADDING=3 CELLSPACING=1>
     <tr>
       <td></td>
       <td ALIGN=CENTER COLSPAN = 2> <b>First Element (Head)</b></td>
       <td ALIGN=CENTER COLSPAN = 2> <b>Last Element (Tail)</b></td>
     </tr>
     <tr>
       <td></td>
       <td ALIGN=CENTER><em>Throws exception</em></td>
       <td ALIGN=CENTER><em>Special value</em></td>
       <td ALIGN=CENTER><em>Throws exception</em></td>
       <td ALIGN=CENTER><em>Special value</em></td>
     </tr>
     <tr>
       <td><b>Insert</b></td>
       <td ALIGN=CENTER>addFirst(e)</td>
       <td ALIGN=CENTER>offerFirst(e)</td>
       <td ALIGN=CENTER>addLast(e)</td>
       <td ALIGN=CENTER>offerLast(e)</td>
     </tr>
     <tr>
       <td><b>Remove</b></td>
       <td ALIGN=CENTER>removeFirst()</td>
       <td ALIGN=CENTER>pollFirst()</td>
       <td ALIGN=CENTER>removeLast()</td>
       <td ALIGN=CENTER>pollLast()</td>
     </tr>
     <tr>
       <td><b>Examine</b></td>
       <td ALIGN=CENTER><a>getFirst()</a></td>
       <td ALIGN=CENTER>peekFirst()</td>
       <td ALIGN=CENTER><a>getLast()</a></td>
       <td ALIGN=CENTER>peekLast()</td>
     </tr>
    </table>
   
   与Queue不同的是，获取而不删除的方法由`element()`变成了`getXXX()`，这些方法用来在队列头/尾中插入/删除/检查元素，当操作失败时有不同的处理：一组直接抛出异常，一组返回一个特殊值（null或false），同样地，返回特殊值的方法适用于有限容量的队列
   
   由于Deque继承自Queue，当**其作为Queue使用时，是一个FIFO队列**，新元素会添加至队尾，删除操作删除队首元素，因此下表的方法在Deque作为Queue使用时是等价的：
   
   | Queue Methods | Equivalent Deque Methods |
   | :-----------: | :----------------------: |
   |    add(e)     |        addLast(e)        |
   |   offer(e)    |       offerLast(e)       |
   |   remove()    |      removeFirst()       |
   |    poll()     |       pollFirst()        |
   |   element()   |        getFirst()        |
   |    peek()     |       peekFirst()        |
   
   此外，**Deque还可以作为LIFO队列**（栈）使用，当作为栈使用时，新元素会从队首添加或删除，这种情况下，`java.util.Stack`的方法和Deque的方法是等价的：
   
   | Stack Methods | Equivalent Deque Methods |
   | :-----------: | :----------------------: |
   |    push(e)    |       addFirst(e)        |
   |     pop()     |      removeFirst()       |
   |    peek()     |       peekFirst()        |
   
   > ArrayDeque 就是一个LIFO队列实现
   
   和List不同的是，Deque**不提供**使用索引操作集合的方法
   
   和Queue一样，虽然没有严格约束不能插入`null`到队列中，也强烈不推荐将`null`值插入，原因和Queue是一样的
   
   除此之外，Deque还提供2个删除元素的方法：
   
   > boolean removeFirstOccurrence(Object o);
   >
   > boolean removeLastOccurrence(Object o);

### 11.2.1 PriorityQueue

**优先级队列**是一个有序队列，其**底层是由堆( *heap* )实现的**，堆是一个可以自我调整的**二叉树**。优先级队列的排序依据可以来自元素的自然排序（实现Comparable接口）或自定义比较器，当使用自然排序规则时，优先级队列不允许插入non-comparable对象

优先级队列不允许`null`值

优先级队列的第一个元素(head)总是按照排序规则计算出最小元素，如果有几个相等的最小元素，那么head为其中任意一个，当使用`poll(`)或`remove()`后，其他最小元素自动移动至head

> 优先级队列并没有对所有元素进行排序，或者说其呈现的结果是树结构<sup> ?</sup>

优先级队列是自动扩容的，其扩容机制为：

- 当队列较小时（<64），容量翻倍
- 当队列长度>64时，容量增加一半（和ArrayList 一样）

优先级队列也有迭代器，此迭代器不能按照指定排序规则顺序迭代元素——优先级队列并没有对所有元素进行排序，若想获得所有元素的排序，可以使用`Arrays.sort(pq.toArray())`

参考下例：

```java
static void unsorted(){
  Queue<Integer> pq = new PriorityQueue<>();
  pq.add(7);
  pq.add(1);
  pq.add(12);
  pq.add(6);
  pq.add(9);
  pq.add(1);
  System.out.println("pq: " + Arrays.toString(pq.toArray()));
  Object[] array = pq.toArray();
  Arrays.sort(array);
  System.out.println("sorted array:" + Arrays.toString(array));
  // the least element always in the head of queue
  pq.poll();
  pq.forEach((e) ->{
    System.out.print(e + "\t");
  });
}
/* output:
pq: [1, 6, 1, 7, 9, 12]
sorted array:[1, 1, 6, 7, 9, 12]
1	6	12	7	9	
///:~
```

和上面的叙述一样，PriorityQueue并没有对所有元素进行排序，不过其保证了最小元素始终在队首，并且队列发生结构性变化时，队列中的元素“位置”也会发生变化

下例展示了如何在PriorityQueue中使用自定义比较器：

```java
static void userComparator() {
  class PC {
    private String model;
    private Double price;

    private PC(String model, Double price) {
      this.model = model;
      this.price = price;
    }
  }

  // compare by price descend
  Queue<PC> pq = new PriorityQueue<>((o1, o2) -> (int) (o2.price - o1.price));
  pq.add(new PC("dell", 15499d));
  pq.add(new PC("apple", 18899d));
  pq.add(new PC("samsung", 8999d));
  pq.add(new PC("asus", 12999d));
  pq.add(new PC("hp", 6399d));
  pq.add(new PC("lenovo", 16999d));

  pq.forEach(e -> System.out.print(e.price + "\t"));
  System.out.println();
  pq.remove();
  pq.forEach(e -> System.out.print(e.price + "\t"));
  System.out.println();
  pq.remove();
  pq.forEach(e -> System.out.print(e.price + "\t"));
  System.out.println();

  // compare by model ascend
  Queue<PC> pq1 = new PriorityQueue<>((o1,o2) -> (o1.model.compareTo(o2.model)));
  pq1.add(new PC("samsung", 8999d));
  pq1.add(new PC("apple", 18899d));
  pq1.add(new PC("lenovo", 16999d));
  pq1.add(new PC("asus", 12999d));
  pq1.add(new PC("dell", 15499d));
  pq1.add(new PC("hp", 6399d));
  pq1.forEach(e -> System.out.print(e.model + "\t"));
  System.out.println();
  pq1.remove();
  pq1.forEach(e -> System.out.print(e.model + "\t"));
  System.out.println();
  pq1.remove();
  pq1.forEach(e -> System.out.print(e.model + "\t"));
}
/* output:
18899.0	15499.0	16999.0	12999.0	6399.0	8999.0	
16999.0	15499.0	8999.0	12999.0	6399.0	
15499.0	12999.0	8999.0	6399.0	
apple	asus	hp	samsung	dell	lenovo	
asus	dell	hp	samsung	lenovo	
dell	lenovo	hp	samsung	
///:~
```

从结果来看，元素在PriorityQueue里**并不是全排序的**，不过其会自动将”最小“的元素移动至队首

此例中，如果不在构造器中指定比较器，PriorityQueue会在运行时抛出 `ClassCastException`——试图将`PC`向上转型为Comparable时异常

### 11.2.2 LinkedList

LinkedList是Deque的实现，可以作为双端队列使用，其实现了Deque声明的所有方法

想讲LinkedList作为Deque使用，须将其声明为 Deque

```java
Deque<String> deque = new LinkedList<>();
```

LinkedList基于链表节点的灵活性，很容易就能够实现在首尾两端对元素进行操作

### 11.2.3 ArrayDeque

ArrayDeque是由**循环数组**实现的双端队列，没有容量限制，并且能够自动扩容，**不允许**插入`null`值

ArrayDeque作为栈（ *LIFO* 队列）使用时，效率比`java.util.Stack`高

ArrayDeque作为Queue使用时，效率比LinkedList高

ArrayDeque的迭代器也是 *fail-fast* 的，意味着和ArrayList一样，在获取迭代器之后使用集合方法对队列进行结构性修改会引发 *ConcurrentModificationException* 

ArrayDeque主要的字段域有：

```java
transient Object[] elements;
transient int head;
transient int tail;
private static final int MIN_INITIAL_CAPACITY = 8;
```

elements用于存储数据，head和tail分别用来标记队列的头尾。 *MIN_INITIAL_CAPACITY* 是创列的最小容量（2<sup>3</sup>）。当构造器没有指定容量时，初始化容量为16；只有当指定容量且**数值小于8时**才会使用8作为初始容量

<span id="resize">参考如下源码</span>：

```java
// ArrayDeque初始化时容量的计算
private static int calculateSize(int numElements) {
  int initialCapacity = MIN_INITIAL_CAPACITY;
  // Find the best power of two to hold elements.
  // Tests "<=" because arrays aren't kept full.
  if (numElements >= initialCapacity) {
    initialCapacity = numElements;
    initialCapacity |= (initialCapacity >>>  1);
    initialCapacity |= (initialCapacity >>>  2);
    initialCapacity |= (initialCapacity >>>  4);
    initialCapacity |= (initialCapacity >>>  8);
    initialCapacity |= (initialCapacity >>> 16);
    initialCapacity++;

    if (initialCapacity < 0)   // Too many elements, must back off
      initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
  }
  return initialCapacity;
}
```

若指定容量>8时，那么需要对其进行**5次右移及位或运算保证最终的容量大小是2<sup>n</sup>**，比如传进来的参数是13，那么最后得到的容量就是2<sup>4</sup>

ArrayDeque中，当`head==tail`时触发扩容，容量增加一倍

参考如下源码：

```java
public void addFirst(E e) {
    //...
    if (head = (head - 1) & (elements.length - 1) == tail)
      doubleCapacity();
    //...
}
public void addLast(E e) {
    //...
    if (tail = (tail + 1) & (elements.length - 1) == head)
      doubleCapacity();
    //...
}
public E pollFirst() {
    //...
    if (head = (h + 1) & (elements.length - 1) == tail)
      doubleCapacity();
  	//...
}
public E pollLast() {
  	//...
    if (tail = (tail - 1) & (elements.length - 1) == head)
      doubleCapacity();
    //...
}
// 扩容
private void doubleCapacity() {
  assert head == tail;
  int p = head;
  int n = elements.length;
  int r = n - p; // number of elements to the right of p
  int newCapacity = n << 1;
  if (newCapacity < 0)
    throw new IllegalStateException("Sorry, deque too big");
  Object[] a = new Object[newCapacity];
  System.arraycopy(elements, p, a, 0, r);
  System.arraycopy(elements, 0, a, r, p);
  elements = a;
  head = 0;
  tail = n;
}
```

一般地，循环队列都是使用**模运算**实现的，而ArrayDeque通过**位运算**来实现循环队列，Java集合框架中很多地方都使用了位运算（如HashMap的扩容），位运算和模运算有如下关系：

> x % 2<sup>n</sup> = x & (2<sup>n</sup> - 1)

并且**位运算的效率远远高出模运算**，这就是Java设计的高明之处

当触发扩容时，将容量增加一倍，同时使用两次`System.arraycopy`将原数组拷贝到新数组中，现引用[ArrayDeque扩容](https://www.jianshu.com/p/b65c22587bdb)将其机制作简要阐述：

> 假如默认容量16，此时数组情况如图
> ![JOvQtx.png](https://s1.ax1x.com/2020/05/01/JOvQtx.png)
>
> 当再次调用`addFirst("G")`时，
>
> ![JOvUHA.png](https://s1.ax1x.com/2020/05/01/JOvUHA.png)
>
> 此时head==tail，触发扩容，将会创建一个大小为 **16*2** 的新数组，然后通过两次拷贝将原数组的数据复制到新数组
>
> - 第一次将***G-H***拷贝到新数组
> - 第二次将***A-F***拷贝到新数组
>
> ![JOvXU1.jpg](https://s1.ax1x.com/2020/05/01/JOvXU1.jpg)
>
> <p style="text-align:center;font-style:italic;font-size:.9rem">ArrayDeque扩容图解<sup>  来源见水印</sup></p>

参考如下示例：

```java
void initializationTest() throws Exception {
  Deque<Integer> aq = new ArrayDeque<>(5);
  // actual circle array size: 8
  System.out.println("array size : " + getElements(aq).length);
  // double capacity while i = 7
  for (int i = 0; i < 8; i++) {
    aq.offerLast(i);
  }
  Object[] elements = getElements(aq);
  System.out.println(Arrays.toString(elements));
  aq.addLast(19);
  aq.forEach(e-> System.out.print(e + "\t"));
}

private <T> T[] getElements(Deque<?> aq) throws Exception {
  Class<?> cls = ArrayDeque.class;
  Field ef = cls.getDeclaredField("elements");
  ef.setAccessible(true);
  return  (T[]) ef.get(aq);
}
/* output:
array size : 8
[0, 1, 2, 3, 4, 5, 6, 7, null, null, null, null, null, null, null, null]
0	1	2	3	4	5	6	7	19	
```

ArrayDeque的具体方法就不再赘述了，其囊括了作为Queue以及Stack的的实现

## 11.3 <span id="set">Set</span>

Set是**不含重复元素的集**，严格来讲，Set不允许当`e1.equals(e2)`为真时， *e1* 和 *e2* 同时出现在集合中。Set最多允许一个`null`元素 

将**可变对象**置入Set时需要特别小心，当对象的改动影响到了元素之间的`equals()`比较的结果，那么Set的行为就变得不确定了。因此，**不能将Set本身作为Set的元素**

### 11.3.1 <span id="hashtable">散列集</span>

数组和链表能够记录元素的插入顺序，这对于通过索引快速对元素执行操作很有利，但是如果忘记了索引，那么需要从头遍历，这在数据量很大的情况下效率低下。在**不考虑元素的顺序情况下，能提供快速查询**所需要的数据，这就是**散列表**(*hash table*)

散列表为每个对象计算一个整数，称为**散列码**(*hash code*)，这意味着如果将自定义对象作为Set的对象，那么必须要**负责实现这个类的*hashCode*方法**，还有一点要注意的是，hashCode和equals方法之间存在[约束关系](#hashCode)，因此**最好也重写equals方法以保证一致性**

Java中的散列表是用**链表数组**实现的，每个链表称为**桶**

<img src="https://s1.ax1x.com/2020/05/03/YSl88s.png" alt="YSl88s.png" style="zoom:50%;margin-left: 300px" />

<p style="text-align:center;font-size:.9rem;font-style:italic">散列表(hash table)  <sup> form Core Java</sup></p>

设有散列表桶数为 *x* ，有对象 *y* ，那么散列表如何存入对象呢？

$$
z = hash(y) \% x
$$
那么对象 *y* 应该放在 *z* 号**桶**中

若桶被**占满**[^8]了，就会发生**散列冲突(*hash collection*)**，散列表会尽量避免散列冲突

> 在Java 8 中，桶满时链表会转换成为*平衡二叉树*

**保证散列中桶数富余能够有效提升散列表的性能**，反之若要插入的元素过多，散列表的性能就会降低

散列表一般可初始化桶数，通常将桶数设置为容量的75%～150%。若不知道元素的个数，散列表太满就会导致**再散列**（ *rehashed* ），在散列就是创建一个桶数更多的表（加倍），将所有的元素copy到新表，丢弃原来的表。在散列由**桶数**和**装填因子（ *load factor* ）**两方面决定，如果不加指定，**装填因子默认为0.75**，若
$$
散列元素数 > 桶数 * 装填因子
$$
就会发生**再散列**

Java标准类库中，散列表的桶数总是2<sup>n</sup>，默认值是16

#### 11.3.1.1 HashSet

HashSet是由HashMap实现的基于散列表的集合，允许至多一个`null`元素

不论桶数，当元素被合理地分配在散列表的桶中时，HashSet的基本操作（add，remove，contains和size）的效率是一致的；但是迭代HashSet所需要的时间消化则与元素数量以及组成**集**的HashMap桶数正相关。因此合理的设置桶数非常有必要

与List不同的是，HashSet的迭代器不能保证元素的迭代顺序，并且迭代器也是 *fail-fast* 的，在使用迭代器时同样需要留意 *ConcurrentModificationException*

HashSet主要字段：

>  ```java
>  private transient HashMap<E,Object> map;
>  
>  // Dummy value to associate with an Object in the backing Map
>  private static final Object PRESENT = new Object();
>  ```

HashSet构造器：

> ```java
> public HashSet() {map = new HashMap<>();}
> public HashSet(Collection<? extends E> c) {...}
> public HashSet(int initialCapacity, float loadFactor) {...}
> public HashSet(int initialCapacity) {...}
> ```

**所以HashSet就是一个所有值为`new Object()`的 HashMap的KeySet**，参考如下示例：

```java
static void initializationTest() throws Exception {
  Set<Integer> hs = new HashSet<>();

  hs.add(1);
  hs.add(2);

  Class<?> cls = HashSet.class;

  Field fm = cls.getDeclaredField("map");
  fm.setAccessible(true);
  System.out.println(fm.get(hs).getClass());
  @SuppressWarnings("unchecked")
  HashMap<Integer, Object> o = (HashMap<Integer, Object>) fm.get(hs);
  System.out.println(o.get(1).getClass());
}
/* output
class java.util.HashMap
class java.lang.Object
///:~
```

**如果将自定义对象存入HashSet，必须覆盖 *equals* 和 *hashCode* 方法** 

#### 11.3.1.2 LinkedHashSet

HashSet的子类，与HashSet的 区别在于LinkedHashSet使用双端链表维护集中的元素，因此元素能够被有序迭代（迭代顺序是元素的插入顺序），当元素添加到集中时，便会并入LinkedList中

<img src="https://s1.ax1x.com/2020/05/06/YAQUu4.png" alt="YAQUu4.png" style="zoom:67%; margin-left: 260px" />

<p style="text-align:center;font-size:.9rem;font-style:italic">链表散列表 <sup> from Core Java</sup></p>

HashSet中有一个包访问权限的构造器，专门用来构造LinkedHashSet：

```java
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
  map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
```

可以看到，LinkedHashSet实质上是LinkedHashMap的是个KeySet

和<span id="performance">HashSet</span>的区别（性能上）:

- 性能稍微比HashSet低一点
- 由于加入了链表，迭代LinkedHashSet时只与集合的容量(size)有关，而与桶数无关；而HashSet的迭代效率与二者都有关
- LinkedHashSet设置过大的桶数所带来的性能（负）影响小于HashSet

### 11.3.3 TreeSet

**树集**是由**红—黑树**实现的有序集合(*sorted collection*)。在Java集合框架中，TreeSet由TreeMap实现，和HashSet一样，**TreeSet是TreeMap的所有值为`new Object()`的keySet**

TreeSet是NavigableSet和SortedSet的实现，其中NavigableSet接口继承了SortedSet接口

<span id="sortedset">SortedSet</span>接口定义了如下方法：

> - **Comparator<? super E> comparator();**
>
>   获取用于排序的比较器，若使用comparable则返回null
>
> - **SortedSet\<E\> subSet(E fromElement, E toElement);**
>
>   返回一个子集，元素范围从 *fromElement* （含）到 *toElement* （不含），当 *fromElement* 和 *toElement* 相等时，返回空集，返回的集合是一个**视图**，对此视图的修改会作用到原集合上，反之亦然
>
> - **SortedSet\<E\> headSet(E toElement);**
>
> - **SortedSet\<E\> tailSet(E fromElement);**
>
>   返回一个子集，元素小于/大于 *toElement/fromElement* ，返回的集合是一个**视图**，对此视图的修改会作用到原集合上，反之亦然
>
> - **E first();**
>
> - **E last();**
>
>   获取集合中最小/最大的元素

NavigableSet继承了SortedSet，并新增了方法：

> - **E lower(E e);**
>
> - **E higher(E e);**
>
>   返回小于 *e* 的最大/大于 *e* 的 最小元素，若不存在则返回null
>
> - **E floor(E e);**
>
> - **E ceiling(E e);**
>
>   返回小于等于 *e* 的最大/大于等于 *e* 的 最小元素，若不存在则返回null
>
> - **E pollFirst();**
>
> - **E pollLast();**
>
>   获取并删除集合中的最小/最大元素，若集合为空则返回null
>
> - **Iterator<E> descendingIterator();**
>
>   获取倒序迭代器

TreeSet中的元素总是有序的，排序规则可以是默认的自然排序（ *comparable* ）或在构造器中指定比较器（ *comparator* ），和**PriorityQueue一样，若向TreeSet插入未排序的元素，会抛出*ClassCastException***

需要注意的是，在使用自定义比较规则时，置入TreeSet中的元素需要考虑到***comparable/comparator* 方法和*equals*方法的一致性**

参考如下示例：

```java
static void consistenceTest() {
  class Item implements Serializable {
    private int code;
    private String name;

    public Item(int code, String name) {
      this.code = code;
      this.name = name;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      Item item = (Item) o;

      if (code != item.code) return false;
      return Objects.equals(name, item.name);
    }

    @Override
    public int hashCode() {
      int result = code;
      result = 31 * result + (name != null ? name.hashCode() : 0);
      return result;
    }
  }
  SortedSet<Item> ss = new TreeSet<>((o1, o2) -> o1.code - o2.code + 1);
  ss.add(new Item(1, "apple"));
  ss.add(new Item(1, "apple"));
  // Set中出现重复元素
  ss.forEach(System.out::println);
}
/* output:
TreeSetTest$1Item@58b8379
TreeSetTest$1Item@58b8379
///:~
```

上例中，对于Item对象 *a* 和 *b* ，以及Item的比较器 *c* ，有
$$
a.equals(b) \&\& c.compare(a,b)!=0
$$
成立，那么第二次add()就会返回true，此时TreeSet中出现了**重复的元素**！这与**Set.add**方法的约束相悖，为什么？原因在于尽管Set是以equals来判断元素相等的，但是TreeSet使用的是比较器规定的方法，上例在TreeSet的角度看， *a* 和 *b* 并不等，**这样会使集合出现难以理解的行为**

因此，**保持比较器和equals方法的一致性是很重要的**

值得一提的是，NavigableSet的获取子集的方法，可以用来对原集合进行修改；同样地，**若原集合发生改变，子集也会随之改变**

> 这与ArrayList的SubList不同，获取子集后对原集合的修改会引发*ConcurrentModificationException*

```java
static void eleTest() {
  TreeSet<String> ss = new TreeSet<String>() {{
    add("nokia");
    add("motorola");
    add("apple");
    add("samsung");
    add("mi");
    add("oppo");
    add("vivo");
    add("sony");
    add("google");
  }};

  SortedSet<String> headSet = ss.headSet("oppo", false);
  // equals 
  // SortedSet<String> headSet = ss.headSet("oppo");
  ss.add("huawei"); // 之前的子集中也会添加
  Iterator<String> i = headSet.iterator();
  int j = 0;
  while (i.hasNext()) {
    j++;
    i.next();
    if (j % 2 == 0) {
      i.remove();
    }
  }
  headSet.forEach(System.out::println);
  System.out.println("contains google? " + ss.contains("google"));
  // 获取当前集合的逆序迭代器
  Iterator<String> i2 = ss.descendingIterator();
  System.out.println("vivo".equals(i2.next()));
}
/* output:
apple
huawei
motorola
contains google? false
true
///:~
```

上例中，获取headSet之后对原集合添加元素，且添加的元素正好在子集的范围中 ，那么子集中也会添加这个元素；

##  11.4 Map

Map即映射，即键-值对，键不允许重复，并且一个键最多映射一个值

映射提供3种**集合视图**

- 键集 （Set实现）
- 值集 （Collection实现）
- Map.Entry集（Set实现）

由于Map的键是Set，因此使用可变对象作为Map的key时，**需要覆盖 *equals* 和 *hashCode* 方法**，**Map不能使用自身作为key**

Java 8对Map接口进行了优化，新增了主要是针对**函数式接口**的 *默认* 方法（方法体被省略）：

> - default V ***merge***(K key, V value,
>               BiFunction<? super V, ? super V, ? extends V> remappingFunction) {...}
> - default V ***compute***(K key,
>               BiFunction<? super K, ? super V, ? extends V> remappingFunction) {...}
> - default V ***computeIfPresent***(K key,
>               BiFunction<? super K, ? super V, ? extends V> remappingFunction) {...}
> - default V ***computeIfAbsent***(K key,
>               Function<? super K, ? extends V> mappingFunction) {...}
> - default V ***replace***(K key, V value) {...}
> - default boolean ***replace***(K key, V oldValue, V newValue) {...}
> - default boolean ***remove***(Object key, Object value) {...}
> - default V ***putIfAbsent***(K key, V value) {...}
> - default void ***replaceAll***(BiFunction<? super K, ? super V, ? extends V> function) {...}
> - default V ***getOrDefault***(Object key, V defaultValue) {...}

上述方法使用的不多，主要用来对Map键值进行更新，按需查阅API文档

### 11.4.1 HashMap

HashMap是由散列表对键进行散列的，允许null键和null值。HashMap是无序的，这点和HashSet是一样的

> HashMap和**Hashtable**大致相同，区别在与Hashtable是同步的，且Hashtable**不允许null**

HashMap的初始化和扩容机制叙述参见[散列表](#hashtable)，默认容量时16，桶数总是2<sup>n</sup>，最大桶数是2<sup>30</sup>，每次扩容加倍，**当桶数大于最大桶数后，不再rehash**。桶数总是为2的幂次的原理和[ArrayDeque一致](#resize)，通过5次位运算将低位全部转为1，然后执行+1操作进位，变成下一个2<sup>n</sup>

HashMap使用`table`和`entrySet`分别表示表示桶数和当前映射中的键值对数：

> transient Node<K,V>[] table;	桶数组
>
> transient Set<Map.Entry<K,V>> entrySet; 映射中的键值对数
>
> int threshold; 临界键值对数，等于 table.length * loadFactor
>
> final float loadFactor; 装载因子，默认0.75

```java
static void bucketsTest() throws Exception {
  // initial capacity 8, load factor 0.75, threshold 6
  HashMap<String, String> hm = new HashMap<>(7);
  hm.put("1", "ok");
  hm.put("2", "fine");
  hm.put("3", "nice");
  hm.put("4", "no");
  hm.put("5", "ops");
  hm.put("6", "fuck");

  Class<?> cls = HashMap.class;

  Field table = cls.getDeclaredField("table");
  Field threshold = cls.getDeclaredField("threshold");
  // Class<?> node = Class.forName("java.util.HashMap$Node");
  table.setAccessible(true);
  threshold.setAccessible(true);
  // Node<K,V>[]
  Object[] o = (Object[]) table.get(hm);
  System.out.println("initial buckets size: " + o.length);
  System.out.println("initial threshold: " + threshold.get(hm));

  Set<Map.Entry<String, String>> entries = hm.entrySet();
  System.out.println("number of entries: " + entries.size());
  // 遍历
  /*entries.forEach((e) -> {
    System.out.println(e.getKey() + e.getValue());
  });*/
  hm.put("apple", "music");
  // reshash needed
  System.out.println(("buckets after rehash: " + ((Object[]) table.get(hm)).length));
}
/* output:
initial buckets size: 8
initial threshold: 6
number of entries: 6
buckets after rehash: 16
///:~
```

上例解释了HashMap的再散列过程，当映射中的**元素数大于桶数与装载因子之积**时，在散列过程发生

Map中提供3种**集合视图**，键的，值的和entry的，视图并不能对映射进行完全结构性控制，比如向Map中添加条目，则只能使用`Map.put`方法，使用视图时，除了**删除**这一改变Map结构的操作，其他操作会抛出*UnsurportedOperationException*

HashMap的集合视图都支持迭代器，并可以通过任意视图的迭代器**删除**键值对，但是不支持新增和替换键值对

```java
private static void viewTest() {
  Map<Integer, String> hm = new HashMap<>(8);
  hm.put(1,"难忘的一天");
  Set<Integer> keySet = hm.keySet();
  //keySet.add(2); // unsupported operation exception
  Iterator<Integer> ikey = keySet.iterator();
  ikey.next();
  // can remove key-value pair by keySet
  ikey.remove();
  ikey.forEachRemaining(System.out::println);

  Collection<String> values = hm.values();
  // already deleted
  System.out.println("values contains: " + values.contains("难忘的一天"));
  // values.add("你瞒我瞒"); // unsupported either
  hm.put(1,"你瞒我瞒");
  hm.put(2,"樱花树下");
  // ikey.next(); // fast-fail iterator, ikey is out of date
  boolean remove = values.remove("你瞒我瞒");
  Iterator<String> ivalue = values.iterator();
  ivalue.next();
  ivalue.remove();

  hm.put(1,"红豆");
  hm.put(2,"风衣");
  Set<Map.Entry<Integer, String>> entries = hm.entrySet();
  // entries.add() // unsupported either
  System.out.println("entry size: " + entries.size());
  // remove entry with particular key-value
  entries.remove(new Map.Entry<Integer, String>() {
    @Override
    public Integer getKey() {
      return 1;
    }
    @Override
    public String getValue() {
      return "红豆";
    }
    @Override
    public String setValue(String value) {
      return null;
    }
  });
  hm.forEach((k,v) -> System.out.println("key:" + k + ", value:" + v));
  Iterator<Map.Entry<Integer, String>> ientry = entries.iterator();
  ientry.next();
  ientry.remove();
  ientry.forEachRemaining(System.out::println);
}
/* output
values contains: false
entry size: 2
key: 2, value:风衣
///:~
```

值得一提的事，和[SortedSet](#sortedset)的子集视图一样，**对原集合和视图的修改是相互的**，不会引发 *ConcurrentModificationException*

至于 *UnsupportedOperationException* 的抛出，查看源码即可知：

![YeQ7rT.png](https://s1.ax1x.com/2020/05/07/YeQ7rT.png)

<p style="text-align:center;font-size:.9rem;font-style:italic">HashMap内部视图和迭代器方法表</p>

可以看到，视图实现的方法有限，并没有实现集合的所有方法。因此当使用视图调用add方法时，直接在**AbstractCollection**里抛出异常：

```java
public boolean add(E e) {
  throw new UnsupportedOperationException();
}
```

### 11.4.2 LinkedHashMap

LInkedHashMap(链表散列映射)是HashMap的导出类，像LinkedHashSet与HashSet的关系一样

LinkedHasMap和HashMap的[性能差异](#performance)与HashSet和LinkedHashSet一致

一般地，LinkedHashMap使用**插入顺序**（ *insertion order* ）。但有特殊情况，LinkedHashMap提供构造参数`assertOrder`，来根据**访问顺序**（ *access order* ）对映射条目进行迭代：

```java
public LinkedHashMap(int initialCapacity,
                         float loadFactor,
                         boolean accessOrder) {
  super(initialCapacity, loadFactor);
  this.accessOrder = accessOrder;
}
```

当使用访问顺序时，映射条目的会按照最少访问——最多访问的顺序迭代，也就是说每次**有效访问**，受到影响的条目都会“移动”到链表的尾部，这个性质非常适合**“最近最少使用”**（LRU）高速缓存

那么哪些方法是有效访问呢？

- put
- get
- putIfAbsent
- getOrdefault
- compute
- computeIfAbsent
- computeIfPresent
- merge

此外，**replace方法只有的成功替换值之后才是有效访问**

```java
static {
  map.put("hebe", "不醉不会");
  map.put("andy", "谢谢你的爱");
  map.put("lala", "寻人启事");
  map.put("yoga", "成全");
}
static void accessOrderTest() {
  Map<String, String> lhm = new LinkedHashMap<>(8, 0.75f, true);
  lhm.putAll(map);
  System.out.println("entry in access order:");
  // 有效访问会将entry移动至队尾
  lhm.replace("yoga", "说谎");
  // Java 8新增方法
  lhm.computeIfPresent("hebe", (k, v) -> "魔鬼中的天使");
  lhm.put("chua", "坠落");
  lhm.get("lala");
  lhm.forEach((k, v) -> System.out.println("\t" + k + ": " + v));
}
/* output:
entry in access order:
	andy: 谢谢你的爱
	yoga: 说谎
	hebe: 魔鬼中的天使
	chua: 坠落
	lala: 寻人启事
///:~
```

**映射视图的操作不影响迭代顺序**：

```java
static void viewTest() {
  Map<String, String> lhm = new LinkedHashMap<>(8, 0.75f, true);
  lhm.putAll(map);
  lhm.forEach((k, v) -> System.out.println("\t" + k + ": " + v));
  Set<Map.Entry<String, String>> entries = lhm.entrySet();
  // 视图操作不会影响映射的排序
  Iterator<Map.Entry<String, String>> i = entries.iterator();
  for (Map.Entry<String, String> entry : entries) {
    entry.setValue("魔鬼中的天使");
    break;
  }
  System.out.println("------");
  lhm.forEach((k, v) -> System.out.println("\t" + k + ": " + v));
  i.next();
}
/* output:
	hebe: 不醉不会
	lala: 寻人启事
	yoga: 成全
	andy: 谢谢你的爱
------
	hebe: 魔鬼中的天使
	lala: 寻人启事
	yoga: 成全
	andy: 谢谢你的爱
///：～
```

关于LinkedHashMap的一个重要的用途，还涉及到一个方法，利用好此方法可以将LinkedHashMap作为缓存使用

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
 return false;
}
```

这个方法在put或者putAll方法插入**新条目**到映射之后调用，也就是说，使用put更新已有key的value不会触发此操作[^9]

如果方法返回false，不执行操作；返回true，则移除参数`eldest`条目

参数 `eldest`是映射的“最旧的”元素——当前最先插入/最少访问的元素：

```java
// first 为队首entry
if (evict && (first = head) != null && removeEldestEntry(first)) {
K key = first.key;
removeNode(hash(key), key, null, false, true);
}
```

这个方法始终返回false——也就是说**永远不会作任何操作**，可以继承此方法（从访问权限修饰符也知道），用于改变行为

此法可以用来在put和putAll之后操作映射，如此做之后，此法一定要返回false，不再允许映射有后续的操作，原因很简单——若在操作时就remove了`eldest`，返回true之后该如何？

`removeEldestEntry`可以作用于插入顺序和访问顺序的LinkedeHashSet中：

```java
private static void eldestRemoveTest() {
  class Access<K, V> extends LinkedHashMap<K, V> {
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
      return size() > 1;
    }
  }
  Access<Integer, String> access = new Access<>();
  access.put(1, "apple");
  // Access中始终只有最后插入的一个条目
  access.put(2, "google");
  access.forEach((k, v) -> System.out.println(k + ": " + v));
}
/* output
2: google
///:~
```

上例中，每次put后调用`removeEldestEntry`方法，最终映射中只有最后插入的条目

```java
static void lruCacheTest() {
  class Cache<K, V> extends LinkedHashMap<K, Integer> {
    private int count;
		// 访问顺序构造器
    private Cache(int initialCapacity, float loadFactor, boolean accessOrder) {
      super(initialCapacity, loadFactor, accessOrder);
      this.count = 0;
    }

    @Override
    public Integer get(Object key) {
      // Integer value = super.get(key);
      // 使用remove保证put触发removeEldestEntry方法
      Integer value = remove(key);
      put((K) key, ++value);
      return value;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, Integer> eldest) {
      count++;
      if (count == 55) {
        Set<Map.Entry<K, Integer>> entries = entrySet();
        // 典型的在forEach中使用集合方法出现CME异常的情形
        /*for (Map.Entry<K, Integer> entry : entries) {
          	if (entry.getValue() < 8) {
            	System.out.println(entry.getKey() + ": " + entry.getValue());
              // entries.remove(entry); // may cause CME
             }
          }*/
        entries.removeIf(next -> {
          System.out.println(next.getKey() + ": " + next.getValue());
          return next.getValue() < 10;
        });
      }
      //若在此方法中对集合进行修改，那么必须返回false
      return false;
    }
  }
  Cache<Integer, Integer> cache = new Cache<Integer, Integer>(8, 0.75f, true);
  cache.put(1, 0);
  cache.put(2, 0);
  cache.put(3, 0);
  cache.put(4, 0);
  cache.put(5, 0);
  for (int i = 0; i < 50; i++) {
    cache.get(new Random().nextInt(50) % 5 + 1);
  }
  System.out.println("------");
  cache.forEach((k, v) -> System.out.println(k + ": " + v));
}
/* output:
2: 13
5: 8
1: 4
4: 16
3: 9
------
2: 13
4: 16
///:~
```

上例对一个容量为5的LinkedList进行50次随机访问，每次访问后记录访问次数（用value自增），最后删除访问次数不到10次的条目

### 11.4.3 TreeMap

TreeSet是TreeMap的KeySet的封装，TreeMap是使用**红—黑树**对键进行排序的有序映射

TreeMap的继承结构和TreeSet极为相似，对应地，TreeMap是SortedMap和NavigableMap的实现，SortedMap/NavigableMap的接口声明和SortedSet/NavgableSet相似，所声明的方法名都是**自解释型**的，具体可查看JDK文档

要将条目插入TreeMap中，key必须是可排序的，排序方式可以是自然排序或者定义比较器，和TreeSet一样，比较器规则必须和equals方法的结果保持一致，以避免映射中出现重复key-value

TreeMap的**集合视图**和对应的迭代器表现和HashMap一致

- 视图和映射的作用是相互的，即修改映射，视图随之修改，反之亦然，但是视图支持的操作是有限的，注意 *UnsupportedOperationException*
- 迭代器是 *fail-fast* 的， 只支持remove一个改变映射结构的方法

```java
static {
  map.put("hebe", "不醉不会");
  map.put("AMIT","母系社会");
  map.put("Lin","可惜没如果");
  map.put("andy", "一起走过的日子");
  map.put("lala", "寻人启事");
  map.put("yoga", "说谎");
}
static void treeMapTest() {
  Map<String, String> tm = new TreeMap<>(map);
  Set<Map.Entry<String, String>> entries = tm.entrySet();
  tm.put("andy", "来生缘"); // 映射和entrySet是互相作用的
  for (Map.Entry<String, String> entry : entries) {
    entry.setValue("难搞");
    break;
  }
  tm.computeIfPresent("lala", (k, v) -> "失落沙洲");
  // Unsupported Operation Exception
  // entries.add(new Map.Entry<String, String>() {...}); 
  tm.forEach((k, v) -> System.out.println(k + ": " + v));

  // test iterator
  Iterator<Map.Entry<String, String>> ie = entries.iterator();
  ie.next();
  ie.remove();
  // tm.putAll(map); //ConcurrentModificationException
  ie.next();
  ie.forEachRemaining(x -> System.out.print(x + "\t"));
  // 指定比较器
  Map<String, String> tm2 = new TreeMap<>(String::compareToIgnoreCase);
  tm2.putAll(map);
  System.out.println();
  tm2.forEach((k,v)-> System.out.println(k +": " + v));
}
/* output:
AMIT: 难搞
Lin: 可惜没如果
andy: 来生缘
hebe: 不醉不会
lala: 失落沙洲
yoga: 说谎
andy=来生缘	hebe=不醉不会	lala=失落沙洲	yoga=说谎	
AMIT: 母系社会
andy: 一起走过的日子
hebe: 不醉不会
lala: 寻人启事
Lin: 可惜没如果
yoga: 说谎
///:~
```

上例中分别对HashMap使用自然排序和指定比较器的方法，可以看到映射中key的排序差异

当指定TreeMap实现类的名字SortedMap或NavigableMap的实现时，方可使用SortedMap和NavigableMap的实用方法，由于方法名都是解释型的，此处不多作表述：

```java
 static void navigableTest() {
   TreeMap<String, String> tm = new TreeMap<>(map);
   System.out.println(tm.firstEntry().getKey());
   SortedMap<String, String> subMap = tm.subMap("AMIT", "andy"+"0");
   subMap.forEach((k, v) -> System.out.println(k + ", " + v));
   System.out.println(tm.ceilingEntry("AMIt").getKey());
 }
/* output:
AMIT
AMIT, 母系社会
Lin, 可惜没如果
andy, 一起走过的日子
Lin
///:~
```

> 由于subMap方法是“包前不包尾”的（其他获取子映射视图的方法也一样），为了包尾，可以使用上例的方法

NavigableMap对获取子映射视图的方法进行了扩展

## 11.5 Collections

集合框架中一个重要的类，其实是Collection接口的**伴随类**，其中定义了许多实用方法，用来获取**集合视图**，或提供一些方便的操作集合元素的**算法**

由于视图是直接封装的Collection接口，**因此其方法有些局限**，并且由于特殊的设计，部分操作是不允许的（会抛出 *UnsupportedOperationExceptin* ）

### 11.5.1 不可修改视图

顾名思义，一旦获取，其内容不再可以修改，Java集合框架中可以用于获取的不可修改视图有

![YMsn4e.png](https://s1.ax1x.com/2020/05/09/YMsn4e.png)

<p style="text-align:center;font-size:.9rem;font-style:italic">Collections通过静态方法获取的8个不可修改视图</p>

Java中提供的获取**不可修改视图**的方法，只能用来遍历原集合中的信息，无法通过任何手段（集合，迭代器，entry等）修改集合，例如，当调用add方法时，Java的处理方式就是抛出 *UnsupportedOperationException* 异常

```java
public class UnmodifiableViewTest {
    static List<String> l = new ArrayList<String>(){{
        add("fan");
        add("bar");
        add("foo");
        add("anchor");
        add("ripe");
        add("rope");
        add("hope");
    }};
    static Set<String> s = new HashSet<>(l);
    static Map<String,String> m = new HashMap<String, String>(){{
        put("c","cable");
        put("b","bar");
        put("f","floyd");
        put("e","echo");
        put("a","anchor");
        put("d","dribble");
    }};
    public static void main(String[] args) {
//        unmodifiableList();
//        unmodifiableSet();
        unmodifiableMap();
    }

    static void unmodifiableList(){
        List<String> strings = Collections.unmodifiableList(l);
        // strings.add("add"); // USOE
        // strings.remove("bar"); // USOE
        // strings.removeAll(l);// USOE
        strings.forEach(System.out::print);
        ListIterator<String> iterator = strings.listIterator();
        System.out.println(iterator.nextIndex());
        List<String> strings1 = strings.subList(1, 2);
        strings1.forEach(System.out::println);
    }

    static void unmodifiableSet(){
        Set<String> set = Collections.unmodifiableSet(s);
        System.out.println(set.contains("anchor"));
        Iterator<String> i = set.iterator();
        i.next();
        // i.remove(); //USOE
        // set.clear(); // USOE
        TreeSet<String>  ts = new TreeSet<>(s);
        // 使用sorted set构建
        NavigableSet<String> strings = Collections.unmodifiableNavigableSet(ts);
        // String s = strings.pollFirst(); //USOE
        System.out.println(strings.first());
        NavigableSet<String> anchor = strings.headSet("anchor", true);
        //anchor.remove("anchor"); //USOE
        anchor.forEach(System.out::println);
    }

    static void unmodifiableMap(){
        Map<String, String> map = Collections.unmodifiableMap(m);
        // map.replace("a","apple"); //USOE
        Set<Map.Entry<String, String>> e = map.entrySet();
        System.out.println(map.get("f"));
        Iterator<Map.Entry<String, String>> i = e.iterator();
        i.next();
        // i.remove(); //USOE
        TreeMap<String,String> tm = new TreeMap<>(m);
        // 使用sorted map
        NavigableMap<String, String> nm = Collections.unmodifiableNavigableMap(tm);
        System.out.println(nm.ceilingEntry("car").getValue());
        NavigableMap<String, String> sm = nm.subMap("b", true, "d", true);
        // sm.remove("c"); //USOE
        sm.forEach((k,v)-> System.out.println(k+", "+v));
        NavigableMap<String, String> descendingMap = sm.descendingMap();
        descendingMap.forEach((k,v)-> System.out.println(k+", "+v));
    }
}
```

稍微查看源码就知道，不可修改视图的工作方式：

```java
 static class UnmodifiableList<E> extends UnmodifiableCollection<E> 
   implements List<E> 
 {
   //...
   public E get(int index) {return list.get(index);}
   public E set(int index, E element) {
     throw new UnsupportedOperationException();
   }
   public void add(int index, E element) {
     throw new UnsupportedOperationException();
   }
   public E remove(int index) {
     throw new UnsupportedOperationException();
   }
   //...
 }
```

不可修改视图的封装思路就是，当试图改变集合时，**不予处理并抛出异常**

### 11.5.2 同步视图

由于Java集合框架中很多（上述全部）都不是同步的， *Java SE 8 API Specification* 里面重复出现的一段话就是

> ***Note that this implementation is not synchronized.*** If multiple threads access an `ArrayList` instance concurrently, and at least one of the threads modifies the list structurally, it *must* be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the `Collections.synchronizedList`method. This is best done at creation time, to prevent accidental unsynchronized access to the list:
>
```java
    List list = Collections.synchronizedList(new ArrayList(...));
```

因此同步视图就是用来处理并发访问的，除了同步视图之外，`java.util.concurrent`包里提供了线程安全的集合，用于并发环境

[![YQFoad.png](https://s1.ax1x.com/2020/05/09/YQFoad.png)](https://imgchr.com/i/YQFoad)

<p style="text-align:center;font-size:.9rem;font-style:italic">Collections通过静态方法获取的8个同步视图（不包含SynchronizedRandomAccessList）</p>

### 11.5.3 受查视图

受查视图用来对泛型类发生问题时提供调试支持

![YQXSk8.png](https://s1.ax1x.com/2020/05/09/YQXSk8.png)

<p style="text-align:center;font-size:.9rem;font-style:italic">Collections通过静态方法获取的9个受查视图（不包含checkededRandomAccessList）</p>

### 11.5.4 实用方法

#### 11.5.4.1 空集合

Collections提供了一些**返回空集合、映射、迭代器**的方法，实际上返回的是Collections所封装的对应的对象

向返回的空集合中插入元素会抛出 *UnsupportedOperationException*

```java
static void emptyList(){
  List<Object> emptyList = Collections.emptyList();
  //emptyList.add(1); // USOE
  System.out.println(emptyList.size()); // actual 0
}
```

#### 11.5.4.2 单一元素集合

Collections还提供了返回指定1个元素的集合或映射

```java
static void singletonList(){
  Set<String> singlton = Collections.singleton("singlton");
  System.out.println(singlton.size()); // actual 1
  // singlton.add("sin"); // USOE
  // singlton.clear(); // USOE
}
```

同样地，单一元素集合也是**不可修改**的

#### 11.5.4.3 其他有利算法

Collections类还包含了很多有利的算法，如

> Collections.sort(List\<T>)

根据对集合元素按照**自然顺序升序排序**，而

> Collections.binarySearch(List<? extends Comparable<? super T>> list, T key)

会**二分查找**集合中的元素，其前提是元素是自然升序排序的[^10]

除此之外，Collections还定义了一些实用方法，简单列出部分：

> public static void reverse(List<?> list) 
>
> public static void shuffle(List<?> list)
>
> public static void shuffle(List<?> list, Random rnd)
>
> public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll)
>
> public static \<T\> T min(Collection<? extends T> coll, Comparator<? super T> comp)
>
> public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
>
> public static \<T\> T max(Collection<? extends T> coll, Comparator<? super T> comp)


[^1]: 集合框架所有迭代器都是如此
[^2]: 这一论点的普适性有待验证
[^3]: 这只是一种表述形式，实际上ArrayList的迭代器是私有内部类，无法使用该语法访问，下同
[^4]: 这和ArrayList的ListIterator没有实现`hasNext()`一样，实际上也是可以使用的(接口动态绑定超类方法)，这种情况在集合框架中很常见
[^5]: 是否一直如此？集合框架中的视图（子集、键集、条目映射、Collections视图等等）都是基于基本接口的内部类实现
[^6]: LinkedList使用和索引相关的操作get()/set()/add()/remove()的效率是一致的
[^7]: 这种情况在获取集合视图(Collection view)时经常出现
[^8]: 每个桶里都有元素么？每个桶至多有多少元素？通过源码来看HashSet和HashMap一个桶里至多有一个元素

[^9]: 实际上使用put更新已有key的value时，触发的是另一个方法：`afterNodeAccess`，此方法将条目移动至队尾（如果使用访问顺序）
[^10]: 排序和查找有重载方法，具体请查看API文档
[^11]: SubList并没有集合视图的共性，其操作集合的方法是独特的；它被称为集合视图的原因是其不是标准的Java集合框架成员
